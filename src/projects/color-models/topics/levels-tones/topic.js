(() => {
  const STYLE_ID = "topic-levels-tones-styles";
  const STORAGE_KEY = "designbook.levels-tones.v1";

  const Kit = window.DesignBookKit;
  if (!Kit) {
    console.error("[levels-tones] DesignBookKit not loaded. Did you include src/designbook-kit.js?");
    return;
  }
  const { clamp } = Kit.math;
  const { escapeRegExp } = Kit.text;
  const { hashStringToU32, mulberry32, randomSeed } = Kit.rand;

  const LEVELS = [
    "#000000",
    "#1A1A1A",
    "#333333",
    "#4D4D4D",
    "#666666",
    "#808080",
    "#999999",
    "#B3B3B3",
    "#CCCCCC",
    "#E6E6E6",
    "#FFFFFF",
  ];

  const TEMPLATE_SVG_URL = "./imges/影调示例.svg";
  const TEMPLATE_SVG_INLINE = `<svg width="1014" height="1306" viewBox="0 0 1014 1306" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_1608_297)">
<rect width="1014" height="1306" fill="white"/>
<rect width="1014" height="1306" fill="#888888"/>
<rect x="283" y="1171" width="461" height="59" fill="#D9D9D9"/>
<rect x="158" y="1048" width="711" height="76" fill="#D9D9D9"/>
<circle cx="514.368" cy="689.632" r="311.368" fill="#D9D9D9"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M534.886 304C547.445 306.417 575.61 313.337 577.175 313.722C579.823 314.368 583.09 317.896 584.353 320.258C589.884 330.584 594.359 345.016 599.259 356.111C605.618 370.512 612.15 384.836 618.524 399.227C618.716 399.661 618.907 400.095 619.099 400.53C624.028 411.678 628.856 422.869 633.426 434.173C633.489 434.328 633.551 434.483 633.614 434.638C633.989 435.567 634.362 436.496 634.733 437.426C634.898 437.84 635.062 438.254 635.227 438.668C635.512 439.387 635.796 440.106 636.079 440.825C636.244 441.244 636.407 441.663 636.571 442.082C636.831 442.746 637.089 443.411 637.347 444.075C637.575 444.665 637.804 445.254 638.031 445.843C638.071 445.948 638.111 446.053 638.151 446.157C638.505 447.081 638.858 448.005 639.208 448.931C639.254 449.052 639.3 449.173 639.346 449.294C639.701 450.236 640.056 451.179 640.407 452.122L640.476 452.201C640.996 452.753 642.242 453.356 643.988 453.984C644.321 454.104 644.671 454.224 645.039 454.345C647.793 455.256 651.479 456.209 655.439 457.134C656.495 457.381 657.571 457.626 658.653 457.868C659.195 457.988 659.738 458.108 660.281 458.227C661.91 458.583 663.541 458.931 665.131 459.265C666.191 459.488 667.233 459.703 668.245 459.912C670.268 460.331 672.169 460.719 673.848 461.068C676.366 461.59 678.385 462.021 679.566 462.325C698.013 467.062 716.24 472.967 734.605 477.91C737.52 478.693 742.05 477.952 743.3 480.539C743.35 480.642 743.395 480.751 743.434 480.865C743.572 481.266 743.641 481.735 743.628 482.287C743.625 482.445 743.615 482.609 743.598 482.78C743.572 483.037 743.531 483.31 743.473 483.6L648.986 504.261C648.931 505.469 648.917 506.664 649.15 507.873C649.222 508.24 649.299 508.614 649.382 508.993C649.465 509.373 649.554 509.758 649.647 510.15C650.86 515.233 652.91 521.251 654.755 527.304C654.897 527.77 655.038 528.236 655.177 528.702C655.316 529.168 655.454 529.633 655.589 530.098C655.804 530.838 656.012 531.576 656.214 532.311C656.956 535.003 657.599 537.652 658.049 540.178C658.634 543.464 658.894 546.542 658.621 549.232C658.539 550.024 657.586 555.732 656.293 563.357C654.845 571.892 652.967 582.827 651.395 591.953C650.839 595.178 650.324 598.177 649.878 600.764L648.299 609.898L686.662 588.93H688.089C688.107 588.944 688.123 588.96 688.14 588.977C688.426 589.263 688.669 589.927 688.843 590.593C688.945 590.984 689.024 591.377 689.074 591.694C689.093 591.821 689.109 591.936 689.119 592.033C689.468 595.508 689.353 607.085 689.056 621.872C688.975 625.905 688.882 630.177 688.779 634.588C688.439 649.291 688.011 665.545 687.709 679.672C687.649 682.497 687.594 685.237 687.545 687.863C687.399 695.741 687.314 702.588 687.335 707.611C687.124 708.945 686.228 710.195 685.09 711.334C684.928 711.497 684.76 711.657 684.589 711.815C683.562 712.764 682.404 713.629 681.394 714.394C681.058 714.648 680.738 714.892 680.444 715.123C672.848 721.105 665.079 726.926 657.227 732.663C655.656 733.81 654.082 734.954 652.506 736.095C636.742 747.507 620.717 758.644 605.147 770.118L601.001 774.526C601.171 774.567 601.33 774.594 601.48 774.611C601.705 774.635 601.911 774.634 602.104 774.612C602.812 774.533 603.354 774.183 604.09 773.853C625.872 764.049 648.3 751.69 670.013 741.048C677.466 737.396 686.278 731.299 693.717 728.415C694.561 728.088 695.365 727.911 696.141 727.854C696.399 727.835 696.654 727.83 696.906 727.837C697.032 727.84 697.158 727.846 697.283 727.855C697.532 727.874 697.78 727.904 698.024 727.945C700.593 728.373 702.912 729.963 705.425 731.422C706.732 732.18 708.195 733.031 709.789 733.963C710.913 734.62 712.104 735.318 713.352 736.051C713.711 736.262 714.075 736.476 714.444 736.693C715.797 737.489 717.212 738.324 718.679 739.193C719.098 739.441 719.522 739.693 719.949 739.947C721.497 740.865 723.098 741.815 724.741 742.796C752.342 759.274 791.895 783.82 793.459 789.438C794.063 791.58 793.912 794.903 794.489 797.334C795.976 803.596 797.442 809.864 798.895 816.134C768.792 883.822 715.243 938.774 648.563 970.68C655.962 944.956 663.732 919.311 671.468 894.1C671.797 893.029 671.879 890.777 671.262 889.789C669.917 890.667 670.521 892.301 670.082 893.441C669.684 894.47 668.462 894.471 668.133 895.075C653.618 921.949 641.344 951.644 627.75 979.717C592.632 993.456 554.409 1001 514.424 1001C476.622 1001 440.393 994.257 406.876 981.911C407.621 951.089 408.473 920.283 409.065 889.486C409.207 881.843 408.077 869.509 408.824 861.183C408.83 861.11 408.836 861.037 408.843 860.965C408.859 860.794 408.877 860.625 408.894 860.458C408.905 860.354 408.917 860.251 408.928 860.149C408.946 859.991 408.965 859.836 408.985 859.682C408.999 859.569 409.014 859.456 409.029 859.345C409.084 858.946 409.143 858.561 409.21 858.189C409.214 858.163 409.219 858.136 409.224 858.11C409.261 857.909 409.3 857.712 409.34 857.519C409.602 856.275 410.261 855.161 411.19 854.15C411.333 853.995 411.482 853.842 411.637 853.691C412.18 853.164 412.796 852.666 413.463 852.192C413.654 852.057 413.849 851.924 414.047 851.793C414.644 851.399 415.274 851.022 415.926 850.66C417.013 850.058 418.159 849.496 419.307 848.964C419.766 848.751 420.225 848.543 420.681 848.339C422.96 847.318 425.151 846.395 426.785 845.477C431.187 843.009 435.696 840.529 440.25 838.034C444.804 835.54 449.403 833.032 453.986 830.507C456.278 829.245 458.566 827.979 460.842 826.709C467.671 822.898 474.395 819.05 480.808 815.157C484.294 813.043 485.736 812.452 484.652 808.278C482.899 801.527 479.605 793.595 476.215 785.817C475.838 784.953 475.46 784.091 475.083 783.232C472.821 778.081 470.588 773.065 468.813 768.58C468.593 768.026 468.374 767.473 468.156 766.922C466.11 761.766 464.112 756.733 462.159 751.696C461.85 750.9 461.543 750.103 461.236 749.306C458.782 742.929 456.397 736.517 454.071 729.816C453.665 728.657 452.934 727.746 452.405 726.768C452.158 726.312 451.954 725.841 451.849 725.324C451.819 725.176 451.796 725.025 451.783 724.869C451.731 724.244 451.827 723.547 452.149 722.73C452.33 722.273 452.524 721.905 452.731 721.603C452.813 721.483 452.898 721.373 452.984 721.273C453.461 720.721 453.997 720.454 454.576 720.246C454.997 720.094 455.441 719.974 455.902 719.798C456.248 719.666 456.604 719.502 456.967 719.27C458.182 718.491 459.378 717.765 460.568 717.069C461.162 716.722 461.755 716.381 462.347 716.045C462.939 715.71 463.53 715.379 464.123 715.05C466.492 713.736 468.874 712.452 471.351 711.017C502.624 692.943 533.959 675.294 565.234 657.386C575.66 651.416 586.079 645.418 596.486 639.366C597.248 636.694 597.86 633.94 598.412 631.154C599.33 626.512 600.078 621.781 601.056 617.189C602.151 612.054 603.264 607.209 604.182 602.416C604.515 600.674 604.823 598.938 605.094 597.197C605.365 595.457 605.599 593.713 605.787 591.953C606.304 587.112 606.466 582.151 606.058 576.832C606.04 576.591 606.019 576.348 605.998 576.105C605.936 575.375 605.863 574.638 605.778 573.894C605.685 573.086 605.337 572.187 604.789 571.237C604.515 570.762 604.19 570.274 603.823 569.777C603.64 569.529 603.445 569.278 603.241 569.026C603.139 568.9 603.034 568.774 602.927 568.648C601.644 567.128 600.02 565.566 598.244 564.088C597.652 563.595 597.043 563.112 596.425 562.643C596.057 562.365 595.686 562.092 595.313 561.825C594.901 561.529 594.487 561.24 594.071 560.96C593.858 560.816 593.643 560.675 593.43 560.535C593.227 560.403 593.024 560.274 592.822 560.146C592.703 560.071 592.585 559.997 592.466 559.924C592.31 559.828 592.155 559.733 591.999 559.639C591.037 559.061 590.089 558.542 589.182 558.099C588.442 557.738 587.729 557.429 587.057 557.178C586.881 557.113 586.708 557.051 586.538 556.994C586.474 556.972 586.41 556.951 586.346 556.931C586.043 556.834 585.751 556.751 585.469 556.683C584.833 556.529 584.256 556.45 583.753 556.461C583.471 556.467 583.213 556.501 582.981 556.565C582.209 556.777 580.707 557.553 578.81 558.648C578.511 558.822 578.201 559.002 577.883 559.191C575.956 560.33 573.715 561.728 571.454 563.173C570.594 563.723 569.731 564.281 568.88 564.834C563.397 568.394 558.465 571.752 558.426 571.779L557.067 595.796L528.326 604.048L521.971 567.879C521.971 567.879 520.019 568.078 516.825 568.413C507.242 569.419 486.477 571.649 473.671 573.399C473.562 573.499 473.41 573.631 473.221 573.795C471.204 575.533 464.822 580.791 457.304 586.951C453.95 589.699 450.37 592.627 446.851 595.502C435.284 604.953 424.375 613.831 424.315 613.88L374.409 600.369L373.229 601.851L358.433 663.781C358.762 664.508 359.297 664.673 360.038 664.797C361.095 664.965 362.816 665.077 364.878 665.152C371.066 665.378 380.332 665.278 383.978 665.399C384.151 665.405 384.312 665.412 384.459 665.419C384.754 665.433 384.993 665.448 385.171 665.467C385.259 665.476 385.333 665.486 385.389 665.497C385.436 665.505 385.483 665.516 385.53 665.529C385.624 665.554 385.72 665.588 385.816 665.628C385.864 665.648 385.913 665.67 385.961 665.694C386.009 665.717 386.057 665.742 386.106 665.769C386.252 665.849 386.398 665.942 386.544 666.044C387.701 666.86 388.764 668.264 388.779 668.284C388.792 668.366 403.274 760.135 403.672 760.739C404.324 761.046 405.289 761.428 406.484 761.85C406.962 762.019 407.477 762.195 408.023 762.375C409.934 763.004 412.227 763.686 414.669 764.325C415.368 764.508 416.078 764.686 416.795 764.86C420.917 765.858 425.264 766.669 428.802 766.873C429.11 766.891 429.411 766.904 429.705 766.912C429.853 766.916 429.998 766.919 430.142 766.921C430.43 766.924 430.711 766.923 430.984 766.916C431.53 766.902 432.044 766.867 432.522 766.808C435.495 766.448 440.163 764.218 443.953 763.45C444.313 763.377 444.666 763.318 445.009 763.274C445.18 763.252 445.35 763.234 445.516 763.22C445.848 763.193 446.168 763.185 446.475 763.196C447.09 763.218 447.65 763.322 448.138 763.53C448.26 763.583 448.378 763.641 448.49 763.707C448.603 763.773 448.711 763.845 448.814 763.925L464.626 803.046C464.625 803.148 464.613 803.252 464.593 803.358C464.574 803.464 464.546 803.572 464.508 803.681C464.211 804.557 463.37 805.545 462.245 806.556C461.963 806.809 461.663 807.064 461.35 807.318C460.097 808.335 458.622 809.352 457.181 810.279C456.821 810.511 456.463 810.737 456.11 810.956C454.351 812.051 452.745 812.97 451.793 813.537C433.291 824.522 412.58 833.119 394.009 844.214L392.732 845.682C392.721 845.998 392.709 846.403 392.696 846.891C392.69 847.134 392.683 847.399 392.676 847.683C392.619 850.124 392.551 854.065 392.468 859.198L392.466 859.198C392.086 882.747 391.418 931.38 390.286 975.249C368.614 965.81 348.225 953.975 329.454 940.078C318.45 917.39 307.543 894.635 297.272 871.622C297.176 870.276 297.08 869.342 298 868.202C299.272 866.644 319.577 850.83 337.038 837.075C339.92 834.806 342.723 832.591 345.351 830.507C347.343 828.928 349.233 827.423 350.98 826.025C352.026 825.187 353.021 824.387 353.955 823.632C355.541 822.351 356.953 821.2 358.144 820.211L295.858 752.953C295.845 750.688 298.398 749.507 300.1 748.216C304.342 744.985 309.072 741.861 314.017 738.795C315.006 738.182 316.003 737.572 317.007 736.963C317.509 736.658 318.013 736.354 318.518 736.051C328.112 730.284 338.188 724.674 346.875 718.886C352.863 714.895 358.54 710.454 364.428 706.309C364.723 706.102 365.018 705.896 365.314 705.69C365.905 705.279 366.498 704.871 367.094 704.467C369.778 702.65 372.521 700.915 375.37 699.332L373.97 686.534C373.914 686.53 353.824 685.187 346.286 684.735C335.196 684.062 334.372 683.417 336.692 672.335C342.099 646.424 350.856 619.331 355.4 593.654C356.662 586.527 350.527 582.476 347.041 576.956L344.954 576.269C344.276 576.446 343.596 576.621 342.917 576.795C332.73 579.4 322.475 581.674 312.22 584.055C303.923 585.984 295.591 587.814 287.244 589.618C283.071 590.52 278.893 591.415 274.714 592.314C270.536 593.212 266.356 594.113 262.177 595.026C259.106 595.696 255.08 597.052 251.384 598.116C250.644 598.329 249.918 598.529 249.215 598.711C248.337 598.938 247.495 599.134 246.71 599.285C246.396 599.345 246.091 599.398 245.797 599.443C245.649 599.465 245.505 599.485 245.363 599.503C243.297 599.771 242.435 598.999 242.372 597.876C242.364 597.736 242.369 597.59 242.385 597.44C242.442 596.916 242.641 596.341 242.95 595.773C243.038 595.61 243.135 595.449 243.24 595.289C243.503 594.89 243.817 594.502 244.169 594.148C257.942 582.817 271.976 571.794 285.936 560.696C289.038 558.23 292.136 555.76 295.228 553.282C302.956 547.088 310.638 540.844 318.217 534.484C319.553 533.364 323.116 530.884 326.111 528.481C326.443 528.215 326.769 527.948 327.083 527.685C328.972 526.107 330.47 524.634 330.749 523.692C330.635 519.469 330.864 515.274 331.248 511.091C331.28 510.742 331.313 510.393 331.347 510.045C331.381 509.697 331.416 509.348 331.452 509C332.1 502.731 333.03 496.485 333.617 490.214C334.962 475.901 336.316 461.605 337.697 447.314C337.838 445.863 337.98 444.412 338.121 442.961C340.187 421.672 342.319 400.392 344.583 379.084C345.434 371.01 343.389 362.098 350.417 356.111C355.138 352.074 360.162 347.831 364.924 343.877C370.181 339.524 377.141 335.624 382.713 331.477C385.942 330.502 428.817 336.05 447.03 338.233C476.265 326.657 505.473 315.054 534.886 304ZM355.386 487.234L354.15 488.058C353.061 494.185 352.384 500.517 351.993 506.851C351.954 507.484 351.917 508.118 351.883 508.752C351.749 511.285 351.659 513.815 351.604 516.33C351.591 516.958 351.579 517.586 351.57 518.212L620.711 458.522C624.019 456.078 621.082 454.814 620.341 452.988C617.446 445.856 614.297 438.917 611.698 431.707L611.186 430.262L355.386 487.234Z" fill="black"/>
<path d="M743.499 483.595L743.471 483.609C743.472 483.606 743.472 483.603 743.473 483.6L743.499 483.595Z" fill="black"/>
<path d="M134.985 181.191C129.074 181.191 123.547 180.798 118.404 180.011C113.338 179.28 109.078 178.297 105.623 177.06C102.169 175.823 99.3288 174.643 97.1027 173.519C94.9533 172.394 93.1494 171.27 91.6909 170.146L94.5695 149.657C97.7168 152.749 101.939 155.447 107.235 157.751C112.532 160 118.251 161.124 124.392 161.124C130.533 161.124 134.947 160.646 137.633 159.691C140.397 158.735 141.779 156.993 141.779 154.463C141.779 151.765 140.205 149.46 137.058 147.549C133.987 145.638 128.652 143.333 121.053 140.635C118.289 139.623 115.948 138.724 114.029 137.937C112.11 137.094 109.538 135.745 106.314 133.89C103.167 131.979 100.595 130.011 98.5995 127.988C96.6037 125.908 94.8381 123.266 93.3029 120.062C91.7676 116.802 91 113.317 91 109.607C91 89.5395 106.468 79.5059 137.403 79.5059C142.316 79.5059 146.922 79.8994 151.221 80.6863C155.596 81.4171 159.012 82.2321 161.468 83.1315C163.925 84.0309 166.151 85.0989 168.147 86.3355C170.219 87.5159 171.524 88.3591 172.062 88.865C172.599 89.3147 172.983 89.6801 173.213 89.9611L167.456 106.234C164.462 103.648 160.701 101.737 156.172 100.501C151.719 99.2078 147.459 98.5614 143.391 98.5614C133.565 98.5614 128.652 100.81 128.652 105.307C128.652 106.487 128.959 107.555 129.573 108.511C130.187 109.466 131.185 110.338 132.567 111.125C133.949 111.911 135.215 112.586 136.367 113.148C137.595 113.71 139.246 114.413 141.318 115.256C143.467 116.043 145.079 116.689 146.154 117.195C157.362 120.68 165.575 124.812 170.795 129.59C176.092 134.368 178.74 140.186 178.74 147.043C178.74 158.173 174.979 166.661 167.456 172.507C160.01 178.297 149.186 181.191 134.985 181.191Z" fill="#BEBEBE"/>
<path d="M229.054 179.421H190.941V80.602H229.054V119.725H258.646V80.602H296.759V179.421H258.646V139.118H229.054V179.421Z" fill="#BEBEBE"/>
<path d="M393.682 179.421H312.045V80.602H391.955L389.652 100.501L350.158 99.6575V118.713H381.247V138.443L350.158 136.757V159.185L393.682 158.342V179.421Z" fill="#BEBEBE"/>
<path d="M442.02 146.537V179.421H403.793V80.602H418.992C422.676 80.602 428.165 80.4896 435.457 80.2647C442.75 79.9837 448.776 79.8432 453.535 79.8432C470.116 79.8432 482.475 82.5132 490.611 87.8532C498.825 93.1933 502.932 101.372 502.932 112.389C502.932 118.91 500.974 124.699 497.06 129.758C493.221 134.817 488.117 138.836 481.745 141.816C485.2 142.434 488.155 143.867 490.611 146.116C493.145 148.364 495.102 151.034 496.484 154.126C497.866 157.161 499.055 160.253 500.053 163.401C501.128 166.492 502.318 169.556 503.623 172.591C505.005 175.627 506.501 177.903 508.113 179.421H465.625C464.781 178.634 464.128 176.442 463.668 172.844C463.207 169.19 462.555 164.834 461.71 159.775C460.943 154.66 459.83 150.388 458.371 146.959C458.217 146.959 458.026 146.959 457.795 146.959C456.337 146.959 454.763 146.959 453.074 146.959C451.462 146.903 450.042 146.847 448.814 146.79C447.586 146.734 446.281 146.678 444.899 146.622C443.594 146.565 442.635 146.537 442.02 146.537ZM442.02 130.855H445.705C447.624 130.855 449.236 130.798 450.541 130.686C451.846 130.573 453.266 130.377 454.802 130.096C456.414 129.758 457.719 129.253 458.716 128.578C459.791 127.903 460.789 127.032 461.71 125.964C462.631 124.896 463.322 123.519 463.783 121.833C464.243 120.146 464.474 118.179 464.474 115.931V109.27C464.474 104.379 462.708 100.978 459.177 99.0673C455.723 97.0999 450.733 96.1162 444.208 96.1162H442.02V130.855Z" fill="#BEBEBE"/>
<path d="M515.459 179.421V80.602H553.572V156.824H587.885V179.421H515.459Z" fill="#BEBEBE"/>
<path d="M637.478 141.225C637.478 150.556 638.438 157.049 640.357 160.703C642.353 164.356 645.807 166.183 650.72 166.183C654.328 166.183 657.053 165.537 658.895 164.244C660.737 162.895 662.119 160.169 663.04 156.065C664.038 151.906 664.537 145.694 664.537 137.431V117.111C664.537 109.073 663.462 103.086 661.313 99.1516C659.164 95.2168 655.633 93.2495 650.72 93.2495C645.807 93.2495 642.353 95.1887 640.357 99.0673C638.438 102.89 637.478 109.888 637.478 120.062V141.225ZM648.302 181.191C641.93 181.191 636.173 180.77 631.03 179.927C625.964 179.083 621.588 177.903 617.904 176.385C614.219 174.868 610.995 172.928 608.231 170.568C605.545 168.207 603.357 165.677 601.668 162.979C600.056 160.281 598.751 157.133 597.753 153.536C596.755 149.882 596.065 146.256 595.681 142.659C595.297 139.005 595.105 134.902 595.105 130.349C595.105 123.603 595.566 117.729 596.487 112.727C597.485 107.724 599.289 103.03 601.899 98.6457C604.508 94.205 607.963 90.6075 612.262 87.8532C616.637 85.0989 622.241 82.9348 629.073 81.3609C635.981 79.787 644.118 79 653.483 79C659.931 79 665.727 79.4497 670.87 80.3491C676.013 81.1922 680.427 82.3727 684.112 83.8903C687.796 85.408 690.982 87.3754 693.669 89.7925C696.432 92.2096 698.62 94.7953 700.232 97.5496C701.921 100.248 703.264 103.424 704.262 107.077C705.26 110.731 705.951 114.357 706.335 117.954C706.718 121.552 706.91 125.627 706.91 130.18C706.91 136.925 706.411 142.799 705.413 147.802C704.415 152.805 702.612 157.499 700.002 161.883C697.392 166.211 693.899 169.752 689.523 172.507C685.148 175.205 679.506 177.341 672.597 178.915C665.765 180.433 657.667 181.191 648.302 181.191Z" fill="#BEBEBE"/>
<path d="M804.08 172.423L803.044 173.35C802.277 173.912 800.972 174.643 799.129 175.542C797.364 176.385 795.214 177.257 792.681 178.156C790.225 178.999 786.924 179.702 782.779 180.264C778.634 180.882 774.181 181.191 769.422 181.191C759.366 181.191 750.769 179.983 743.63 177.566C736.491 175.093 730.887 171.523 726.819 166.858C722.827 162.136 719.948 156.824 718.183 150.922C716.417 144.963 715.534 138.078 715.534 130.264C715.534 121.945 716.417 114.778 718.183 108.764C719.948 102.693 722.865 97.381 726.934 92.8279C731.079 88.2186 736.759 84.7616 743.975 82.457C751.191 80.1523 759.98 79 770.343 79C775.102 79 779.555 79.3092 783.7 79.9275C787.922 80.5458 791.223 81.2484 793.602 82.0354C796.059 82.8223 798.246 83.7217 800.166 84.7335C802.161 85.7453 803.39 86.4479 803.85 86.8414C804.388 87.2349 804.771 87.5441 805.002 87.7689L803.274 107.162H785.772L779.785 97.128C778.403 96.847 777.252 96.7064 776.331 96.7064C771.188 96.7064 767.234 97.5777 764.471 99.3202C761.707 101.007 759.596 104.351 758.138 109.354C756.679 114.3 755.95 121.439 755.95 130.77C755.95 136.335 756.411 141.197 757.332 145.357C758.33 149.517 759.52 152.721 760.901 154.969C762.283 157.161 763.933 158.932 765.853 160.281C767.772 161.63 769.499 162.501 771.034 162.895C772.569 163.232 774.22 163.401 775.985 163.401C779.9 163.401 784.007 163.063 788.306 162.389C792.604 161.658 796.135 160.562 798.899 159.101L804.08 172.423Z" fill="#BEBEBE"/>
<path d="M879.627 179.421C878.706 178.578 876.71 175.289 873.639 169.556C870.646 163.766 867.115 157.246 863.046 149.994C859.054 142.687 855.523 137.15 852.453 133.384V179.421H814.34V80.602H852.453V127.903L881.124 80.602H919.467L885.154 126.976C887.38 128.1 890.335 131.164 894.02 136.166C897.705 141.169 901.159 146.425 904.383 151.934C907.607 157.442 910.946 162.979 914.401 168.544C917.855 174.053 920.388 177.678 922 179.421H879.627Z" fill="#BEBEBE"/>
<path d="M220.283 302.229H182.17V203.411H220.283V242.533H249.875V203.411H287.988V302.229H249.875V261.926H220.283V302.229Z" fill="#BEBEBE"/>
<path d="M350.829 293.882C354.206 293.882 356.778 292.87 358.543 290.847C360.386 288.767 361.307 285.928 361.307 282.331V255.687C361.307 244.726 357.776 239.245 350.714 239.245C347.413 239.245 344.841 240.229 342.999 242.196C341.157 244.163 340.236 246.946 340.236 250.543V277.946C340.236 288.57 343.767 293.882 350.829 293.882ZM349.908 304C332.329 304 319.471 301.077 311.334 295.231C303.197 289.385 299.129 280.054 299.129 267.238C299.129 254.534 303.236 244.979 311.449 238.571C319.663 232.106 333.02 228.874 351.52 228.874C369.559 228.874 382.57 231.966 390.554 238.149C398.614 244.276 402.644 253.579 402.644 266.058C402.644 278.986 398.383 288.542 389.863 294.725C381.419 300.908 368.1 304 349.908 304Z" fill="#BEBEBE"/>
<path d="M413.921 302.229V203.411H452.034V279.633H486.347V302.229H413.921Z" fill="#BEBEBE"/>
<path d="M526.152 302.229H491.494L502.202 203.411H556.205L566.338 236.547L570.944 253.326L575.319 236.631L584.3 203.411H632.431L642.333 302.229H606.523L600.651 244.135L599.269 222.719L581.652 292.364H551.599L530.413 222.719L529.722 244.135L526.152 302.229Z" fill="#BEBEBE"/>
<path d="M734.056 302.229H652.418V203.411H732.328L730.025 223.309L690.531 222.466V241.522H721.62V261.252L690.531 259.565V281.993L734.056 281.15V302.229Z" fill="#BEBEBE"/>
<path d="M784.697 304C778.786 304 773.259 303.607 768.116 302.82C763.049 302.089 758.789 301.105 755.335 299.869C751.88 298.632 749.04 297.451 746.814 296.327C744.665 295.203 742.861 294.079 741.402 292.955L744.281 272.466C747.428 275.557 751.65 278.255 756.947 280.56C762.243 282.808 767.962 283.933 774.103 283.933C780.244 283.933 784.658 283.455 787.345 282.499C790.108 281.544 791.49 279.801 791.49 277.272C791.49 274.574 789.916 272.269 786.769 270.358C783.699 268.447 778.364 266.142 770.764 263.444C768.001 262.432 765.659 261.533 763.74 260.746C761.821 259.903 759.25 258.553 756.026 256.699C752.878 254.787 750.307 252.82 748.311 250.796C746.315 248.717 744.55 246.075 743.014 242.871C741.479 239.61 740.711 236.125 740.711 232.415C740.711 212.348 756.179 202.314 787.115 202.314C792.027 202.314 796.633 202.708 800.932 203.495C805.307 204.226 808.723 205.041 811.18 205.94C813.636 206.839 815.862 207.907 817.858 209.144C819.931 210.325 821.236 211.168 821.773 211.674C822.31 212.123 822.694 212.489 822.925 212.77L817.167 229.043C814.174 226.457 810.412 224.546 805.883 223.309C801.431 222.016 797.171 221.37 793.102 221.37C783.276 221.37 778.364 223.618 778.364 228.115C778.364 229.296 778.671 230.364 779.285 231.319C779.899 232.275 780.897 233.146 782.279 233.933C783.66 234.72 784.927 235.395 786.078 235.957C787.307 236.519 788.957 237.221 791.03 238.065C793.179 238.852 794.791 239.498 795.866 240.004C807.073 243.489 815.287 247.62 820.506 252.398C825.803 257.176 828.451 262.994 828.451 269.852C828.451 280.982 824.69 289.469 817.167 295.315C809.721 301.105 798.898 304 784.697 304Z" fill="#BEBEBE"/>
</g>
<defs>
<clipPath id="clip0_1608_297">
<rect width="1014" height="1306" fill="white"/>
</clipPath>
</defs>
</svg>
`;

  const POSITIONS = [
    { id: "dark", label: "暗度", group: [0, 3] },
    { id: "mid", label: "灰度", group: [4, 6] },
    { id: "light", label: "亮度", group: [7, 10] },
  ];

  const LENGTHS = [
    { id: "short", label: "短调", span: 3 },
    { id: "medium", label: "中调", span: 5 },
    { id: "long", label: "长调", span: 11 },
  ];

  // The template SVG uses this fill for the large circle and the (pre-split) bottom bars.
  const CIRCLE_BASE_FILL = "#D9D9D9";
  const BAR_LAYER_PLACEHOLDERS = ["#D9D9DA", "#D9D9DB", "#D9D9DC", "#D9D9DD"];
  const HEADLINE_PLACEHOLDER_TOP = "#BEBEBF";
  const HEADLINE_PLACEHOLDER_BOTTOM = "#BEBEC0";
  // Back-compat aliases (older code may still reference these).
  const HEADLINE_PLACEHOLDER = HEADLINE_PLACEHOLDER_TOP;
  const HEADLINE_PLACEHOLDER_2 = HEADLINE_PLACEHOLDER_BOTTOM;

  function ensureStyles() {
    Kit.css.ensureStyleOnce(
      STYLE_ID,
      `
.lt-root{position:absolute;inset:0;overflow:hidden}
.lt-scroll{position:absolute;inset:0;overflow:auto;padding:var(--space-16)}
.lt{--fg:var(--text);--muted:var(--muted);--border:var(--stroke-2);--glass:var(--glass);--track:rgba(255,255,255,.10);color:var(--fg)}
.lt h2{margin:0 0 var(--space-12);font-size:var(--fs-title);font-weight:780;letter-spacing:.2px}
.lt .sub{margin:0 0 var(--space-16);color:var(--muted);font-size:var(--fs-note);line-height:1.55}
.lt .grid{display:grid;grid-template-columns:1fr;gap:var(--space-12)}
.lt .card{border:1px solid var(--border);background:var(--glass);border-radius:var(--radius-16);padding:var(--space-12)}
.lt .row{display:flex;align-items:center;justify-content:space-between;gap:var(--space-12)}
.lt .left{display:flex;align-items:center;gap:var(--space-8);min-width:0}
.lt .name{font-size:var(--fs-note);opacity:.92;white-space:nowrap}
.lt .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
.lt .muted{color:var(--muted)}
.lt .kbd{font-family:ui-monospace,monospace;padding:0 6px;border:1px solid rgba(255,255,255,.18);border-radius:6px;background:rgba(255,255,255,.06)}
.lt .btn{appearance:none;border:1px solid var(--stroke-2);background:rgba(255,255,255,.05);color:var(--fg);border-radius:var(--radius-12);padding:var(--space-8) var(--space-12);font-size:var(--fs-note);cursor:pointer}
.lt .btn:hover{background:rgba(255,255,255,.08)}
.lt .btn:active{transform:translateY(.5px)}
.lt .btn.small{padding:var(--space-8) var(--space-8)}

.lt-levels{display:grid;grid-template-columns:repeat(11,minmax(0,1fr));gap:var(--space-8)}
.lt-swatch{display:grid;gap:var(--space-8);min-width:0}
.lt-chip{height:30px;border-radius:var(--radius-12);border:1px solid var(--stroke-2);background:#000}
.lt-swatch .lbl{display:grid;grid-template-rows:auto auto;justify-items:center;gap:2px;font-size:11px;color:var(--muted);text-align:center}
.lt-swatch .lbl .idx{opacity:.9}
.lt-swatch .lbl .hex{opacity:.82}
.lt-swatch .lbl span{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

.lt-legend{display:grid;grid-template-columns:repeat(11,1fr);gap:var(--space-8);margin-top:var(--space-12)}
.lt-legend .seg{position:relative;padding-top:var(--space-12)}
.lt-legend .seg::before{content:"";position:absolute;top:0;left:0;right:0;border-top:1px solid rgba(255,255,255,.14)}
.lt-legend .tag{display:inline-flex;align-items:center;gap:var(--space-8);font-size:var(--fs-note);color:rgba(234,240,255,.86)}
.lt-legend .tag small{font-size:11px;color:var(--muted)}

.lt-spans{display:grid;gap:var(--space-12);margin-top:var(--space-12)}
.lt-spanRow{display:grid;grid-template-columns:60px 1fr;gap:var(--space-12);align-items:center}
.lt-spanBar{display:grid;grid-template-columns:repeat(11,1fr);gap:var(--space-8);align-items:stretch}
.lt-spanBar .slot{height:14px;border-radius:999px;border:1px solid rgba(255,255,255,.10);background:rgba(255,255,255,.02)}
.lt-spanBar .slot.on{background:rgba(255,255,255,.10);border-color:rgba(255,255,255,.16)}

.lt-matrix{display:grid;grid-template-columns:70px repeat(3,minmax(0,1fr));gap:var(--space-12);align-items:stretch}
.lt-matrix.lt-matrix--compact{grid-template-columns:repeat(3,minmax(0,1fr))}
.lt-colHead,.lt-rowHead{font-size:var(--fs-note);color:var(--muted);display:flex;align-items:center;justify-content:center}
.lt-corner{color:transparent}
.lt-cell{border:1px solid var(--border);background:var(--glass);border-radius:var(--radius-16);padding:var(--space-12);display:grid;gap:var(--space-12);position:relative}
.lt-cellTitle{display:grid;grid-template-columns:1fr auto auto;align-items:center;gap:var(--space-8)}
.lt-cellTitle .t{font-size:var(--fs-note);font-weight:750}
.lt-cellTitle .r{font-size:11px;color:var(--muted);white-space:nowrap;justify-self:end}
.lt-cellActions{display:flex;gap:var(--space-8);align-items:center;justify-self:end}
.lt-cellActions--abs{position:absolute;top:var(--space-12);right:var(--space-12);z-index:2}
.lt-cellRefresh{width:30px;height:30px;border-radius:var(--radius-12);font-size:14px;opacity:.78}
.lt-cellRefresh--abs{position:absolute;top:10px;right:10px;z-index:2}
.lt-cellRefresh:hover{opacity:1}
.lt-cellLock{width:30px;height:30px;border-radius:var(--radius-12);font-size:14px;opacity:.78}
.lt-cellLock:hover{opacity:1}
.lt-cover{width:100%;height:auto;display:block;border-radius:var(--radius-12);border:1px solid var(--stroke-2);background:rgba(0,0,0,.14)}

.lt-panel{--fg:var(--text);--muted:var(--muted);--border:var(--stroke-2);--track:rgba(255,255,255,.10);color:var(--fg)}
.lt-panel h2{margin:0 0 var(--space-12);font-size:var(--fs-title);font-weight:780;letter-spacing:.2px}
.lt-panel .sub{margin:0 0 var(--space-16);color:var(--muted);font-size:var(--fs-note);line-height:1.55}
.lt-panel .card{border:1px solid var(--border);background:var(--glass);border-radius:var(--radius-16);padding:var(--space-12)}
.lt-panel .row{display:flex;align-items:center;justify-content:space-between;gap:var(--space-12)}
.lt-panel .name{font-size:var(--fs-note);opacity:.92;white-space:nowrap}
.lt-panel input[type="range"]{width:100%;appearance:none;background:transparent;height:18px;--p:50%;--range-fill:#1677ff}
.lt-panel input[type="range"]::-webkit-slider-runnable-track{height:10px;border-radius:999px;background:linear-gradient(to right,var(--range-fill) 0%,var(--range-fill) var(--p),var(--track) var(--p),var(--track) 100%);border:1px solid rgba(255,255,255,.16)}
.lt-panel input[type="range"]::-webkit-slider-thumb{appearance:none;-webkit-appearance:none;margin-top:-6px;width:22px;height:22px;border-radius:999px;background:var(--range-fill);border:2px solid rgba(0,0,0,.35);box-shadow:0 0 0 1px rgba(255,255,255,.12)}
.lt-panel input[type="range"]::-moz-range-track{height:10px;border-radius:999px;background:var(--track);border:1px solid rgba(255,255,255,.16)}
.lt-panel input[type="range"]::-moz-range-progress{height:10px;border-radius:999px;background:var(--range-fill)}
.lt-panel input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:999px;background:var(--range-fill);border:2px solid rgba(0,0,0,.35)}
.lt-panel input[type="checkbox"]{appearance:none;-webkit-appearance:none;width:18px;height:18px;border-radius:6px;border:1px solid rgba(255,255,255,.18);background:var(--track);display:grid;place-items:center;flex:0 0 auto}
.lt-panel input[type="checkbox"]:checked{background:#1677ff;border-color:rgba(255,255,255,.22);background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='18' height='18' viewBox='0 0 18 18'%3E%3Cpath d='M4.2 9.4l2.4 2.6L13.8 5.8' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");background-repeat:no-repeat;background-position:center;background-size:11px 11px}
.lt-panel input[type="checkbox"]:focus-visible{outline:2px solid rgba(22,119,255,.35);outline-offset:2px}
.lt-panel .toggle{display:flex;align-items:center;gap:var(--space-8);font-size:var(--fs-note);opacity:.92}
.lt-panel .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
.lt-panel .uploadActions{display:flex;align-items:flex-start;gap:var(--space-12)}
.lt-panel .uploadStack{display:flex;flex-direction:column;align-items:stretch}
.lt-panel .uploadNote{margin-top:6px;font-size:11px;line-height:1;color:var(--muted);text-align:center}
.lt-panel .drop{margin-top:var(--space-12);border:1px dashed rgba(255,255,255,.18);border-radius:var(--radius-12);padding:var(--space-12);background:rgba(0,0,0,.12);color:rgba(234,240,255,.72);font-size:var(--fs-note);line-height:1.4}
.lt-panel .drop.is-dragover{border-color:rgba(22,119,255,.65);background:rgba(22,119,255,.08)}
.lt-panel .drop .t{font-weight:650;color:rgba(234,240,255,.86)}
.lt-panel .drop .s{margin-top:4px;color:var(--muted);font-size:11px}
.lt-panel .warn{margin-top:8px;color:rgba(255,214,102,.88);font-size:12px;line-height:1.4}
.lt-templCtrl{display:flex;align-items:flex-start;gap:var(--space-12)}
.lt-templMeta{margin-top:var(--space-12);color:var(--muted);font-size:var(--fs-note);line-height:1.45}
.lt-templWarn{margin-top:8px;color:rgba(255,214,102,.88);font-size:12px;line-height:1.4}
.lt .btn.primary,.lt-panel .btn.primary{background:#1677ff;border-color:rgba(22,119,255,.85);color:#fff}
.lt .btn.primary:hover,.lt-panel .btn.primary:hover{background:#0f6ae6}
.lt .btn.primary:active,.lt-panel .btn.primary:active{transform:translateY(.5px)}
.lt-cell.is-selected{border-color:rgba(22,119,255,.55);box-shadow:0 0 0 2px rgba(22,119,255,.18)}

.lt-color{display:grid;gap:var(--space-12)}
.lt-color .pair{display:grid;grid-template-columns:1fr auto;gap:var(--space-8);align-items:center}
.lt-color .pair .lhs{min-width:0}
.lt-color .pair .rhs{display:flex;gap:8px;align-items:center}
.lt-color .rhs select{width:120px;min-width:120px;padding-right:38px}
.lt-color .picker{display:grid;gap:10px}
.lt-color .sb{position:relative;height:160px;border-radius:var(--radius-16);border:1px solid var(--stroke-2);background:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,var(--hueColor,#ff0000));overflow:hidden;touch-action:none}
.lt-color .knob{position:absolute;width:18px;height:18px;border-radius:999px;transform:translate(-9px,-9px);border:2px solid rgba(0,0,0,.55);box-shadow:0 0 0 1px rgba(255,255,255,.75)}
.lt-panel input[type="range"].lt-hue{height:14px}
.lt-panel input[type="range"].lt-hue::-webkit-slider-runnable-track{height:12px;border-radius:999px;border:1px solid rgba(255,255,255,.16);background:linear-gradient(to right,#ff0000,#ffff00,#00ff00,#00ffff,#0000ff,#ff00ff,#ff0000)}
.lt-panel input[type="range"].lt-hue::-webkit-slider-thumb{appearance:none;-webkit-appearance:none;margin-top:-6px;width:22px;height:22px;border-radius:999px;background:rgba(255,255,255,.92);border:2px solid rgba(0,0,0,.45);box-shadow:0 0 0 1px rgba(255,255,255,.12)}
.lt-panel input[type="range"].lt-hue::-moz-range-track{height:12px;border-radius:999px;border:1px solid rgba(255,255,255,.16);background:linear-gradient(to right,#ff0000,#ffff00,#00ff00,#00ffff,#0000ff,#ff00ff,#ff0000)}
.lt-panel input[type="range"].lt-hue::-moz-range-thumb{width:22px;height:22px;border-radius:999px;background:rgba(255,255,255,.92);border:2px solid rgba(0,0,0,.45)}
.lt-color .meta{display:flex;justify-content:space-between;gap:var(--space-12);align-items:center;font-size:var(--fs-note);color:var(--muted)}
.lt-color .swatches{display:flex;flex-wrap:wrap;gap:8px}
.lt-color .sw{display:flex;align-items:center;gap:8px;border:1px solid var(--stroke-2);border-radius:999px;padding:6px 8px;background:rgba(255,255,255,.04);font-size:11px;color:rgba(234,240,255,.86);cursor:pointer;user-select:none}
.lt-color .sw:hover{background:rgba(255,255,255,.06)}
.lt-color .sw.is-active{border-color:rgba(22,119,255,.6);box-shadow:0 0 0 2px rgba(22,119,255,.14)}
.lt-color .dot{width:14px;height:14px;border-radius:6px;border:1px solid var(--stroke-2);background:#000}
.lt-color .sw .val{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;color:var(--muted)}

.lt-pop{position:fixed;z-index:9999;display:none;left:0;top:0;width:min(380px,calc(100vw - 24px))}
.lt-popCard{border:1px solid var(--stroke-2);border-radius:var(--radius-16);padding:var(--space-12);background:rgba(18,20,26,.92);backdrop-filter:blur(10px);box-shadow:0 18px 60px rgba(0,0,0,.45);--track:rgba(255,255,255,.10)}
.lt-popHead{display:flex;align-items:center;justify-content:space-between;gap:var(--space-12)}
.lt-popPill{display:flex;align-items:center;gap:10px;min-width:0}
.lt-popDot{width:18px;height:18px;border-radius:8px;border:1px solid var(--stroke-2);background:#000;flex:0 0 auto}
.lt-popTxt{display:flex;flex-direction:column;min-width:0}
.lt-popTitle{font-size:12px;color:rgba(234,240,255,.92);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.lt-popHex{font-size:11px;color:var(--muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
.lt-popActions{display:flex;gap:8px;align-items:center;flex:0 0 auto}
.lt-popPad{position:relative;height:160px;border-radius:var(--radius-16);border:1px solid var(--stroke-2);background:linear-gradient(to bottom, rgba(255,255,255,.90), rgba(0,0,0,.94)),linear-gradient(to right, rgba(255,255,255,.12), var(--hueColor,#ff0000));overflow:hidden;touch-action:none}
.lt-popBand{position:absolute;left:0;right:0;top:calc(var(--ya,0)*100%);height:calc((var(--yb,1) - var(--ya,0))*100%);background:rgba(22,119,255,.18);border-top:1px solid rgba(22,119,255,.55);border-bottom:1px solid rgba(22,119,255,.55)}
.lt-popKnob{position:absolute;left:calc(var(--x,.5)*100%);top:calc(var(--y,.5)*100%);transform:translate(-9px,-9px);width:18px;height:18px;border-radius:999px;border:2px solid rgba(0,0,0,.55);box-shadow:0 0 0 1px rgba(255,255,255,.75);background:rgba(255,255,255,.06)}
.lt-popMeta{margin-top:8px;font-size:11px;color:var(--muted);display:flex;justify-content:space-between;gap:var(--space-12);align-items:center}
.lt-popMeta .delta{color:rgba(234,240,255,.86)}
.lt-popMeta .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
.lt-popRows{display:grid;gap:10px;margin-top:12px}
.lt-popRow{display:grid;grid-template-columns:72px 1fr 72px;gap:var(--space-12);align-items:center}
.lt-popRow .lab{font-size:11px;color:rgba(234,240,255,.86);white-space:nowrap}
.lt-popRow .val{font-size:11px;color:var(--muted);text-align:right;font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace}
.lt-popRow input[type="range"]{width:100%;appearance:none;background:transparent;height:18px;--p:50%;--range-fill:#1677ff}
.lt-popRow input[type="range"]::-webkit-slider-runnable-track{height:10px;border-radius:999px;background:linear-gradient(to right,var(--range-fill) 0%,var(--range-fill) var(--p),var(--track) var(--p),var(--track) 100%);border:1px solid rgba(255,255,255,.16)}
.lt-popRow input[type="range"]::-webkit-slider-thumb{appearance:none;-webkit-appearance:none;margin-top:-6px;width:22px;height:22px;border-radius:999px;background:var(--range-fill);border:2px solid rgba(0,0,0,.35);box-shadow:0 0 0 1px rgba(255,255,255,.12)}
.lt-popRow input[type="range"]::-moz-range-track{height:10px;border-radius:999px;background:var(--track);border:1px solid rgba(255,255,255,.16)}
.lt-popRow input[type="range"]::-moz-range-progress{height:10px;border-radius:999px;background:var(--range-fill)}
.lt-popRow input[type="range"]::-moz-range-thumb{width:22px;height:22px;border-radius:999px;background:var(--range-fill);border:2px solid rgba(0,0,0,.35)}
`
    );
  }

  function loadState() {
    const raw = Kit.storage.loadJson(STORAGE_KEY, {});
    const cellSeeds = {};
    if (raw.cellSeeds && typeof raw.cellSeeds === "object") {
      for (const [k, v] of Object.entries(raw.cellSeeds || {})) {
        if (typeof v === "number" && Number.isFinite(v)) cellSeeds[k] = v;
      }
    }
    const lockedBaseSeeds = {};
    if (raw.lockedBaseSeeds && typeof raw.lockedBaseSeeds === "object") {
      for (const [k, v] of Object.entries(raw.lockedBaseSeeds || {})) {
        if (typeof v === "number" && Number.isFinite(v)) lockedBaseSeeds[k] = v;
      }
    }

    return {
      showGuides: raw.showGuides !== false,
      showLabels: raw.showLabels !== false,
      texture: typeof raw.texture === "number" ? clamp(raw.texture, 0, 1) : 0.35,
      seed: typeof raw.seed === "number" ? raw.seed : randomSeed(),
      cellSeeds,
      lockedBaseSeeds,
      selectedKey:
        typeof raw.selectedKey === "string" &&
        POSITIONS.some((p) => raw.selectedKey.startsWith(`${p.id}:`)) &&
        LENGTHS.some((l) => raw.selectedKey.endsWith(`:${l.id}`))
          ? raw.selectedKey
          : "dark:short",
      colorDraft:
        raw.colorDraft && typeof raw.colorDraft === "object"
          ? {
              h: clamp(Number(raw.colorDraft.h) || 0, 0, 360),
              s: clamp(Number(raw.colorDraft.s) || 0, 0, 100),
              b: clamp(Number(raw.colorDraft.b) || 0, 0, 100),
              harmony: typeof raw.colorDraft.harmony === "string" ? raw.colorDraft.harmony : "complement",
            }
          : { h: 0, s: 85, b: 65, harmony: "complement" },
      colorByCell: raw.colorByCell && typeof raw.colorByCell === "object" ? raw.colorByCell : {},
    };
  }

  function saveState(s) {
    Kit.storage.saveJson(STORAGE_KEY, s);
  }

  function toneTitle(positionLabel, lengthLabel) {
    const prefix = positionLabel.replace(/度$/, "");
    return `${prefix}${lengthLabel}`;
  }

  function formatRangeLabel([start, end]) {
    return `${start}–${end}`;
  }

  function normalizeHex(hex) {
    const h = String(hex).trim();
    const m = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.exec(h);
    if (!m) return null;
    const raw = m[1];
    if (raw.length === 3) {
      const r = raw[0];
      const g = raw[1];
      const b = raw[2];
      return `#${r}${r}${g}${g}${b}${b}`.toUpperCase();
    }
    return `#${raw}`.toUpperCase();
  }

  function hexToRgb01(hex) {
    const h = normalizeHex(hex);
    if (!h) return null;
    const r = parseInt(h.slice(1, 3), 16) / 255;
    const g = parseInt(h.slice(3, 5), 16) / 255;
    const b = parseInt(h.slice(5, 7), 16) / 255;
    return { r, g, b };
  }

  function srgbToLinear(u) {
    if (u <= 0.04045) return u / 12.92;
    return Math.pow((u + 0.055) / 1.055, 2.4);
  }

  function relLuminanceFromHex(hex) {
    const rgb = hexToRgb01(hex);
    if (!rgb) return 0;
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }

  function relLuminanceFromRgb01(rgb) {
    if (!rgb) return 0;
    const r = srgbToLinear(rgb.r);
    const g = srgbToLinear(rgb.g);
    const b = srgbToLinear(rgb.b);
    return 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }

  function rgb01ToHex({ r, g, b }) {
    const to2 = (u) => Math.max(0, Math.min(255, Math.round(u * 255))).toString(16).padStart(2, "0");
    return `#${to2(r)}${to2(g)}${to2(b)}`.toUpperCase();
  }

  function hsvToRgb01(h, s01, v01) {
    const hh = ((h % 360) + 360) % 360;
    const s = clamp(Number(s01) || 0, 0, 1);
    const v = clamp(Number(v01) || 0, 0, 1);
    const c = v * s;
    const x = c * (1 - Math.abs(((hh / 60) % 2) - 1));
    const m = v - c;
    let rp = 0,
      gp = 0,
      bp = 0;
    if (hh < 60) [rp, gp, bp] = [c, x, 0];
    else if (hh < 120) [rp, gp, bp] = [x, c, 0];
    else if (hh < 180) [rp, gp, bp] = [0, c, x];
    else if (hh < 240) [rp, gp, bp] = [0, x, c];
    else if (hh < 300) [rp, gp, bp] = [x, 0, c];
    else [rp, gp, bp] = [c, 0, x];
    return { r: rp + m, g: gp + m, b: bp + m };
  }

  function wrapHue(h) {
    return ((h % 360) + 360) % 360;
  }

  function harmonyLabel(type) {
    switch (type) {
      case "off":
        return "关闭";
      case "analogous":
        return "类似色";
      case "adjacent":
        return "邻近色";
      case "triadic":
        return "三角色";
      case "split":
        return "分裂互补色";
      case "warmcool":
        return "冷暖色";
      case "complement":
      default:
        return "互补色";
    }
  }

  function harmonyHues(baseHue, type) {
    const h = wrapHue(baseHue);
    switch (type) {
      case "analogous":
        return [wrapHue(h - 30), wrapHue(h + 30)];
      case "adjacent":
        return [wrapHue(h - 60), wrapHue(h + 60)];
      case "triadic":
        return [wrapHue(h + 120), wrapHue(h + 240)];
      case "split":
        return [wrapHue(h + 150), wrapHue(h + 210)];
      case "warmcool":
        return [wrapHue(h + 180)];
      case "off":
        return [];
      case "complement":
      default:
        return [wrapHue(h + 180)];
    }
  }

  let levelBandsCache = null;
  function getLevelLuminanceBands() {
    if (levelBandsCache) return levelBandsCache;
    const lum = LEVELS.map((hex) => relLuminanceFromHex(hex));
    const mids = [];
    for (let i = 0; i < lum.length - 1; i++) mids[i] = (lum[i] + lum[i + 1]) / 2;
    const minDelta = 0.012;
    const maxDelta = 0.045;
    levelBandsCache = lum.map((L, i) => {
      const t = Math.abs(i - 5) / 5;
      const delta = minDelta + (maxDelta - minDelta) * Math.pow(t, 1.6);
      let a = clamp(L - delta, 0, 1);
      let b = clamp(L + delta, 0, 1);

      // Hard boundaries: never cross into adjacent tone indices.
      const hardMin = i === 0 ? 0 : mids[i - 1];
      const hardMax = i === 10 ? 1 : mids[i];
      a = Math.max(a, hardMin);
      b = Math.min(b, hardMax);

      if (a > b) {
        // Fallback to a minimal valid band around L within hard bounds.
        const p = clamp(L, hardMin, hardMax);
        a = p;
        b = p;
      }
      return [a, b];
    });
    return levelBandsCache;
  }

  let levelLumCache = null;
  let levelMidCache = null;
  function getLevelLuminances() {
    if (levelLumCache) return levelLumCache;
    levelLumCache = LEVELS.map((hex) => relLuminanceFromHex(hex));
    return levelLumCache;
  }
  function getLevelMidpoints() {
    if (levelMidCache) return levelMidCache;
    const lum = getLevelLuminances();
    levelMidCache = [];
    for (let i = 0; i < lum.length - 1; i++) levelMidCache[i] = (lum[i] + lum[i + 1]) / 2;
    return levelMidCache;
  }
  function luminanceToToneIndex(L) {
    const x = clamp(Number(L) || 0, 0, 1);
    const mids = getLevelMidpoints();
    for (let i = 0; i < mids.length; i++) if (x <= mids[i]) return i;
    return 10;
  }
  function toneIndexToToneGroup(idx) {
    const i = clamp(Math.round(Number(idx) || 0), 0, 10);
    if (i <= 3) return "dark";
    if (i <= 6) return "mid";
    return "light";
  }
  function hsvSpecToToneGroup(spec) {
    if (!spec || typeof spec !== "object") return null;
    const h = clamp(Number(spec.h) || 0, 0, 360);
    const s = clamp(Number(spec.s) || 0, 0, 100) / 100;
    const v = clamp(Number(spec.b) || 0, 0, 100) / 100;
    const rgb = hsvToRgb01(h, s, v);
    const L = relLuminanceFromRgb01(rgb);
    const idx = luminanceToToneIndex(L);
    return { idx, groupId: toneIndexToToneGroup(idx), L };
  }

  function solveHsvForLuminanceBand({ hue, sat01, targetLum, band }) {
    const [Lmin, Lmax] = band;
    let s = clamp(Number(sat01) || 0, 0, 1);

    const lumAt = (v) => relLuminanceFromRgb01(hsvToRgb01(hue, s, v));
    let hiLum = lumAt(1);
    let guard = 0;
    while (hiLum < Lmin && s > 0.0005 && guard++ < 28) {
      s *= 0.85;
      hiLum = lumAt(1);
    }

    const target = clamp(Number(targetLum) || 0, Lmin, Math.min(Lmax, hiLum));
    let lo = 0;
    let hi = 1;
    for (let i = 0; i < 22; i++) {
      const mid = (lo + hi) / 2;
      const L = lumAt(mid);
      if (L < target) lo = mid;
      else hi = mid;
    }
    const v = (lo + hi) / 2;
    const rgb = hsvToRgb01(hue, s, v);
    return { rgb, h: hue, s, v, L: relLuminanceFromRgb01(rgb) };
  }

  function roleSatScale(role) {
    if (role === "accent") return 1;
    if (role === "dominant") return 0.22;
    return 0.45;
  }

  function toneIndexToHex({ idx, hue, sat01, b01, satScale }) {
    const band = getLevelLuminanceBands()[clamp(idx, 0, 10)];
    const targetLum = band[0] + (band[1] - band[0]) * clamp(Number(b01) || 0, 0, 1);
    const startS = clamp(Number(sat01) || 0, 0, 1) * clamp(Number(satScale) || 1, 0, 1);
    const solved = solveHsvForLuminanceBand({ hue, sat01: startS, targetLum, band });
    return rgb01ToHex(solved.rgb);
  }

  function randInt(rng, min, max) {
    const a = Math.ceil(min);
    const b = Math.floor(max);
    if (b <= a) return a;
    return a + Math.floor(rng() * (b - a + 1));
  }

  function countInside([start, end], [a, b]) {
    const s = Math.max(start, a);
    const e = Math.min(end, b);
    return Math.max(0, e - s + 1);
  }

  function computeToneRange(positionId, lengthId, rng) {
    const pos = POSITIONS.find((p) => p.id === positionId) || POSITIONS[0];
    const [g0, g1] = pos.group;

    if (lengthId === "long") return [0, 10];

    if (lengthId === "short") {
      const start = randInt(rng, g0, g1 - 2);
      return [start, start + 2];
    }

    if (lengthId === "medium") {
      const span = 5;
      const candidates = [];
      for (let start = 0; start <= 10 - (span - 1); start++) {
        const end = start + span - 1;
        if (countInside([start, end], [g0, g1]) >= 3) candidates.push([start, end]);
      }
      return candidates[randInt(rng, 0, candidates.length - 1)] || [g0, Math.min(10, g0 + 4)];
    }

    // unreachable; kept for completeness
    return [0, 10];
  }

  function getToneRange({ positionId, lengthId, seed }) {
    const rng = mulberry32(hashStringToU32(`${seed}:${positionId}:${lengthId}:range`));
    return computeToneRange(positionId, lengthId, rng);
  }

  function extractHexColors(svgText) {
    const set = new Set();
    const re = /#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\b/g;
    let m;
    while ((m = re.exec(svgText))) {
      const norm = normalizeHex(`#${m[1]}`);
      if (norm) set.add(norm);
    }
    if (/\b(fill|stroke)="white"/i.test(svgText)) set.add("#FFFFFF");
    if (/\b(fill|stroke)="black"/i.test(svgText)) set.add("#000000");
    return Array.from(set);
  }

  function parseSvgNumber(v) {
    const n = Number.parseFloat(String(v || "").trim().replace(/[^0-9.+-eE]/g, ""));
    return Number.isFinite(n) ? n : null;
  }

  function parseColorToHex(v) {
    const s = String(v || "").trim();
    if (!s || s === "none" || s.startsWith("url(")) return null;
    if (/^#/.test(s)) return normalizeHex(s);
    if (/^white$/i.test(s)) return "#FFFFFF";
    if (/^black$/i.test(s)) return "#000000";
    return null;
  }

  function isInNonRenderedContainer(el) {
    let cur = el;
    while (cur) {
      const tag = String(cur.tagName || "").toLowerCase();
      if (tag === "defs" || tag === "clippath" || tag === "mask" || tag === "pattern" || tag === "symbol" || tag === "metadata" || tag === "title" || tag === "desc") {
        return true;
      }
      cur = cur.parentElement;
    }
    return false;
  }

  function isVisuallyHidden(el) {
    const disp = String(el.getAttribute("display") || "").trim();
    if (disp === "none") return true;
    const vis = String(el.getAttribute("visibility") || "").trim();
    if (vis === "hidden" || vis === "collapse") return true;

    const opAttr = parseSvgNumber(el.getAttribute("opacity"));
    if (opAttr != null && opAttr <= 0) return true;

    const style = String(el.getAttribute("style") || "");
    if (style) {
      if (/\bdisplay\s*:\s*none\b/i.test(style)) return true;
      if (/\bvisibility\s*:\s*(hidden|collapse)\b/i.test(style)) return true;
      const mOp = /\bopacity\s*:\s*([0-9.]+)/i.exec(style);
      const op = parseSvgNumber(mOp?.[1]);
      if (op != null && op <= 0) return true;
    }
    return false;
  }

  const svgWeightsCache = new Map();
  const svgDominantFillCache = new Map();
  const svgBBoxesCache = new Map();
  function estimateColorWeights(svgText) {
    const key = hashStringToU32(String(svgText || ""));
    if (svgWeightsCache.has(key)) return svgWeightsCache.get(key);

    const out = new Map();
    try {
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      const root = doc.documentElement;
      const vb = String(root.getAttribute("viewBox") || "").trim().split(/\s+/).map(parseSvgNumber).filter((x) => x != null);
      const viewW = vb.length === 4 ? vb[2] : parseSvgNumber(root.getAttribute("width")) || 1000;
      const viewH = vb.length === 4 ? vb[3] : parseSvgNumber(root.getAttribute("height")) || 1000;
      const viewArea = Math.max(1, viewW * viewH);
      const detailWeight = viewArea * 0.001;
      const fullRects = [];

      const add = (hex, w) => {
        if (!hex) return;
        out.set(hex, (out.get(hex) || 0) + w);
      };

      const bboxAreaFromPairs = (nums) => {
        if (!nums || nums.length < 4) return null;
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        for (let i = 0; i + 1 < nums.length; i += 2) {
          const x = nums[i];
          const y = nums[i + 1];
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
        if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return null;
        const a = Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
        return a > 0 ? a : null;
      };

      const extractNums = (s) => {
        const arr = [];
        const re = /-?\d*\.?\d+(?:e[-+]?\d+)?/gi;
        let m;
        while ((m = re.exec(String(s || "")))) arr.push(Number(m[0]));
        return arr;
      };

      const els = root.querySelectorAll("[fill],[stroke],[style]");
      for (const el of els) {
        if (isInNonRenderedContainer(el) || isVisuallyHidden(el)) continue;
        const tag = String(el.tagName || "").toLowerCase();

        let area = detailWeight;
        if (tag === "rect") {
          const w = parseSvgNumber(el.getAttribute("width"));
          const h = parseSvgNumber(el.getAttribute("height"));
          if (w != null && h != null) area = Math.max(detailWeight, w * h);
        } else if (tag === "circle") {
          const r = parseSvgNumber(el.getAttribute("r"));
          if (r != null) area = Math.max(detailWeight, Math.PI * r * r);
        } else if (tag === "ellipse") {
          const rx = parseSvgNumber(el.getAttribute("rx"));
          const ry = parseSvgNumber(el.getAttribute("ry"));
          if (rx != null && ry != null) area = Math.max(detailWeight, Math.PI * rx * ry);
        } else if (tag === "path") {
          const a = bboxAreaFromPairs(extractNums(el.getAttribute("d")));
          if (a != null) area = Math.max(detailWeight, a * 0.35);
        } else if (tag === "polygon" || tag === "polyline") {
          const a = bboxAreaFromPairs(extractNums(el.getAttribute("points")));
          if (a != null) area = Math.max(detailWeight, a * 0.45);
        } else if (tag === "line") {
          const a = bboxAreaFromPairs(
            [el.getAttribute("x1"), el.getAttribute("y1"), el.getAttribute("x2"), el.getAttribute("y2")].map(parseSvgNumber).filter((x) => x != null)
          );
          if (a != null) area = Math.max(detailWeight, a * 12);
        }

        const style = String(el.getAttribute("style") || "");
        const mFill = style ? /\bfill\s*:\s*([^;]+)/i.exec(style) : null;
        const mStroke = style ? /\bstroke\s*:\s*([^;]+)/i.exec(style) : null;
        const sf = parseColorToHex(mFill?.[1]);
        const ss = parseColorToHex(mStroke?.[1]);

        const fill = sf ?? parseColorToHex(el.getAttribute("fill"));
        const stroke = ss ?? parseColorToHex(el.getAttribute("stroke"));
        if (fill) add(fill, area);
        if (stroke) add(stroke, area * 0.65);

        if (style) {
          // no-op: style already applied as override above
        }

        if (tag === "rect" && fill && area >= viewArea * 0.9) {
          fullRects.push({ fill, area });
        }
      }

      // If there are multiple full-canvas rects, only the last one is actually visible as the true "background".
      // Reduce the earlier ones so they don't skew weights and base-layer detection.
      if (fullRects.length > 1) {
        for (let i = 0; i < fullRects.length - 1; i++) {
          const { fill, area } = fullRects[i];
          const prev = out.get(fill) || 0;
          out.set(fill, Math.max(0, prev - area));
        }
      }
    } catch {
      // ignore and return empty weights
    }

    const obj = Object.fromEntries(out.entries());
    svgWeightsCache.set(key, obj);
    return obj;
  }

  function estimateColorBBoxes(svgText) {
    const key = hashStringToU32(String(svgText || ""));
    if (svgBBoxesCache.has(key)) return svgBBoxesCache.get(key);

    const boxes = new Map();
    let viewW = 1000;
    let viewH = 1000;

    const addBox = (hex, b) => {
      if (!hex || !b) return;
      const cur = boxes.get(hex);
      if (!cur) {
        boxes.set(hex, { ...b });
        return;
      }
      cur.minX = Math.min(cur.minX, b.minX);
      cur.minY = Math.min(cur.minY, b.minY);
      cur.maxX = Math.max(cur.maxX, b.maxX);
      cur.maxY = Math.max(cur.maxY, b.maxY);
    };

    const bboxFromPairs = (nums) => {
      if (!nums || nums.length < 4) return null;
      let minX = Infinity,
        minY = Infinity,
        maxX = -Infinity,
        maxY = -Infinity;
      for (let i = 0; i + 1 < nums.length; i += 2) {
        const x = nums[i];
        const y = nums[i + 1];
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
        maxX = Math.max(maxX, x);
        maxY = Math.max(maxY, y);
      }
      if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return null;
      return { minX, minY, maxX, maxY };
    };

    const extractNums = (s) => {
      const arr = [];
      const re = /-?\d*\.?\d+(?:e[-+]?\d+)?/gi;
      let m;
      while ((m = re.exec(String(s || "")))) arr.push(Number(m[0]));
      return arr;
    };

    const fillStrokeFromEl = (el) => {
      const style = String(el.getAttribute("style") || "");
      const mFill = style ? /\bfill\s*:\s*([^;]+)/i.exec(style) : null;
      const mStroke = style ? /\bstroke\s*:\s*([^;]+)/i.exec(style) : null;
      const sf = parseColorToHex(mFill?.[1]);
      const ss = parseColorToHex(mStroke?.[1]);
      const fill = sf ?? parseColorToHex(el.getAttribute("fill"));
      const stroke = ss ?? parseColorToHex(el.getAttribute("stroke"));
      return { fill, stroke };
    };

    try {
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      const root = doc.documentElement;
      const vb = String(root.getAttribute("viewBox") || "")
        .trim()
        .split(/\s+/)
        .map(parseSvgNumber)
        .filter((x) => x != null);
      viewW = vb.length === 4 ? vb[2] : parseSvgNumber(root.getAttribute("width")) || viewW;
      viewH = vb.length === 4 ? vb[3] : parseSvgNumber(root.getAttribute("height")) || viewH;

      const els = root.querySelectorAll("rect,circle,ellipse,path,polygon,polyline,line");
      for (const el of els) {
        if (isInNonRenderedContainer(el) || isVisuallyHidden(el)) continue;
        const tag = String(el.tagName || "").toLowerCase();
        let b = null;
        if (tag === "rect") {
          const x = parseSvgNumber(el.getAttribute("x")) ?? 0;
          const y = parseSvgNumber(el.getAttribute("y")) ?? 0;
          const w = parseSvgNumber(el.getAttribute("width")) ?? 0;
          const h = parseSvgNumber(el.getAttribute("height")) ?? 0;
          if (w > 0 && h > 0) b = { minX: x, minY: y, maxX: x + w, maxY: y + h };
        } else if (tag === "circle") {
          const cx = parseSvgNumber(el.getAttribute("cx"));
          const cy = parseSvgNumber(el.getAttribute("cy"));
          const r = parseSvgNumber(el.getAttribute("r"));
          if (cx != null && cy != null && r != null && r > 0) b = { minX: cx - r, minY: cy - r, maxX: cx + r, maxY: cy + r };
        } else if (tag === "ellipse") {
          const cx = parseSvgNumber(el.getAttribute("cx"));
          const cy = parseSvgNumber(el.getAttribute("cy"));
          const rx = parseSvgNumber(el.getAttribute("rx"));
          const ry = parseSvgNumber(el.getAttribute("ry"));
          if (cx != null && cy != null && rx != null && ry != null && rx > 0 && ry > 0) b = { minX: cx - rx, minY: cy - ry, maxX: cx + rx, maxY: cy + ry };
        } else if (tag === "path") {
          b = bboxFromPairs(extractNums(el.getAttribute("d")));
        } else if (tag === "polygon" || tag === "polyline") {
          b = bboxFromPairs(extractNums(el.getAttribute("points")));
        } else if (tag === "line") {
          b = bboxFromPairs(
            [el.getAttribute("x1"), el.getAttribute("y1"), el.getAttribute("x2"), el.getAttribute("y2")].map(parseSvgNumber).filter((x) => x != null)
          );
        }
        if (!b) continue;

        const { fill, stroke } = fillStrokeFromEl(el);
        if (fill) addBox(fill, b);
        if (stroke) addBox(stroke, b);
      }
    } catch {
      // ignore
    }

    const obj = { viewW, viewH, boxes: Object.fromEntries(boxes.entries()) };
    svgBBoxesCache.set(key, obj);
    return obj;
  }

  function findDominantFillColor(svgText) {
    const key = hashStringToU32(String(svgText || ""));
    if (svgDominantFillCache.has(key)) return svgDominantFillCache.get(key);

    let best = null;
    try {
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      const root = doc.documentElement;
      const vb = String(root.getAttribute("viewBox") || "").trim().split(/\s+/).map(parseSvgNumber).filter((x) => x != null);
      const viewW = vb.length === 4 ? vb[2] : parseSvgNumber(root.getAttribute("width")) || 1000;
      const viewH = vb.length === 4 ? vb[3] : parseSvgNumber(root.getAttribute("height")) || 1000;
      const viewArea = Math.max(1, viewW * viewH);
      const detailWeight = viewArea * 0.001;

      const bboxAreaFromPairs = (nums) => {
        if (!nums || nums.length < 4) return null;
        let minX = Infinity,
          minY = Infinity,
          maxX = -Infinity,
          maxY = -Infinity;
        for (let i = 0; i + 1 < nums.length; i += 2) {
          const x = nums[i];
          const y = nums[i + 1];
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
          minX = Math.min(minX, x);
          minY = Math.min(minY, y);
          maxX = Math.max(maxX, x);
          maxY = Math.max(maxY, y);
        }
        if (!Number.isFinite(minX) || !Number.isFinite(minY) || !Number.isFinite(maxX) || !Number.isFinite(maxY)) return null;
        const a = Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
        return a > 0 ? a : null;
      };

      const extractNums = (s) => {
        const arr = [];
        const re = /-?\d*\.?\d+(?:e[-+]?\d+)?/gi;
        let m;
        while ((m = re.exec(String(s || "")))) arr.push(Number(m[0]));
        return arr;
      };

      const fillFromEl = (el) => {
        const style = String(el.getAttribute("style") || "");
        if (style) {
          const mFill = /\bfill\s*:\s*([^;]+)/i.exec(style);
          const sf = parseColorToHex(mFill?.[1]);
          if (sf) return sf;
        }
        const direct = parseColorToHex(el.getAttribute("fill"));
        if (direct) return direct;
        return null;
      };

      const els = root.querySelectorAll("rect,circle,ellipse,path,polygon,polyline");
      let idx = 0;
      let bestArea = -1;
      let bestIdx = -1;
      for (const el of els) {
        if (isInNonRenderedContainer(el) || isVisuallyHidden(el)) continue;
        idx++;
        const tag = String(el.tagName || "").toLowerCase();
        let area = detailWeight;
        if (tag === "rect") {
          const w = parseSvgNumber(el.getAttribute("width"));
          const h = parseSvgNumber(el.getAttribute("height"));
          if (w != null && h != null) area = Math.max(detailWeight, w * h);
        } else if (tag === "circle") {
          const r = parseSvgNumber(el.getAttribute("r"));
          if (r != null) area = Math.max(detailWeight, Math.PI * r * r);
        } else if (tag === "ellipse") {
          const rx = parseSvgNumber(el.getAttribute("rx"));
          const ry = parseSvgNumber(el.getAttribute("ry"));
          if (rx != null && ry != null) area = Math.max(detailWeight, Math.PI * rx * ry);
        } else if (tag === "path") {
          const a = bboxAreaFromPairs(extractNums(el.getAttribute("d")));
          if (a != null) area = Math.max(detailWeight, a * 0.35);
        } else if (tag === "polygon" || tag === "polyline") {
          const a = bboxAreaFromPairs(extractNums(el.getAttribute("points")));
          if (a != null) area = Math.max(detailWeight, a * 0.45);
        }

        const fill = fillFromEl(el);
        if (!fill) continue;

        const epsilon = viewArea * 0.004;
        if (area > bestArea + epsilon || (Math.abs(area - bestArea) <= epsilon && idx >= bestIdx)) {
          bestArea = area;
          bestIdx = idx;
          best = fill;
        }
      }

      // If we found a near-full-canvas fill, ensure we prefer the last one (topmost) among them.
      if (bestArea >= viewArea * 0.9) {
        let last = best;
        for (const el of els) {
          if (isInNonRenderedContainer(el) || isVisuallyHidden(el)) continue;
          const tag = String(el.tagName || "").toLowerCase();
          if (tag !== "rect") continue;
          const w = parseSvgNumber(el.getAttribute("width"));
          const h = parseSvgNumber(el.getAttribute("height"));
          if (w == null || h == null) continue;
          if (w * h < viewArea * 0.9) continue;
          const fill = fillFromEl(el);
          if (fill) last = fill;
        }
        best = last;
      }
    } catch {
      best = null;
    }

    svgDominantFillCache.set(key, best);
    return best;
  }

  function pickSpreadUnique({ pool, count, rng, used }) {
    if (count <= 0) return [];
    const p = pool.length ? pool.slice() : [];
    if (!p.length) return [];

    const out = [];
    const maxIdx = p.length - 1;
    for (let i = 0; i < count; i++) {
      const t = count === 1 ? 0.5 : i / (count - 1);
      const jitter = (rng() - 0.5) * 0.22;
      const tt = clamp(t + jitter, 0, 1);
      out.push(p[Math.round(tt * maxIdx)]);
    }

    const unique = [];
    const taken = used || new Set();
    for (const idx of out) {
      if (!taken.has(idx)) {
        unique.push(idx);
        taken.add(idx);
        continue;
      }
      const avail = p.filter((x) => !taken.has(x));
      if (!avail.length) {
        unique.push(idx);
        continue;
      }
      const pick = avail[randInt(rng, 0, avail.length - 1)];
      unique.push(pick);
      taken.add(pick);
    }
    return unique;
  }

  function dominantGroupFor(positionId) {
    const pos = POSITIONS.find((p) => p.id === positionId) || POSITIONS[0];
    return pos.group;
  }

  function dominantBandFor({ range, positionId, lengthId }) {
    const [start, end] = range;
    const len = end - start + 1;
    if (len <= 1) return [start, end];

    // For long tones (range=0–10), keep the large-area layers firmly in their "position" group.
    // Small areas can still reach outside the group via the accent pool.
    if (lengthId === "long") {
      const [g0, g1] = dominantGroupFor(positionId);
      const s = Math.max(start, g0);
      const e = Math.min(end, g1);
      if (s <= e) return [s, e];
    }

    const ratio = lengthId === "short" ? 1 : lengthId === "medium" ? 0.8 : 0.55;
    const minBand = lengthId === "short" ? len : lengthId === "medium" ? Math.min(len, 4) : 5;
    let bandLen = clamp(Math.round(len * ratio), minBand, len);

    if (positionId === "dark") return [start, start + bandLen - 1];
    if (positionId === "light") return [end - bandLen + 1, end];

    // mid: center band around the middle of range (prefer including 4–6 if possible).
    const center = clamp(5, start, end);
    let s = clamp(Math.round(center - bandLen / 2), start, end);
    let e = s + bandLen - 1;
    if (e > end) {
      e = end;
      s = e - bandLen + 1;
    }
    return [s, e];
  }

  function computeWeightedColorMap({ svgText, colors, range, positionId, lengthId, templateMode = "default", seedKey, indexToColor, onAssignment }) {
    const [start, end] = range;
    const [g0, g1] = dominantGroupFor(positionId);
    const useTemplateHeuristics = templateMode === "default";

    const weights = estimateColorWeights(svgText);
    const bboxInfo = estimateColorBBoxes(svgText);
    const items = colors.map((c) => ({
      c,
      L: relLuminanceFromHex(c),
      w: typeof weights?.[c] === "number" ? weights[c] : 1,
    }));

    const fullPool = indexList([start, end]);
    let dominantBand = dominantBandFor({ range, positionId, lengthId });
    let domPool = indexList([Math.max(start, dominantBand[0]), Math.min(end, dominantBand[1])]);

    // Ensure enough slots for dominant items; widen within range if needed.
    const desiredDom = lengthId === "short" ? items.length : Math.max(2, Math.round(items.length * (lengthId === "medium" ? 0.8 : 0.68)));
    let guard = 0;
    while (domPool.length < desiredDom && guard++ < 16) {
      if (domPool.length >= fullPool.length) break;
      if (positionId === "dark") dominantBand = [start, Math.min(end, dominantBand[1] + 1)];
      else if (positionId === "light") dominantBand = [Math.max(start, dominantBand[0] - 1), end];
      else dominantBand = [Math.max(start, dominantBand[0] - 1), Math.min(end, dominantBand[1] + 1)];
      domPool = indexList([Math.max(start, dominantBand[0]), Math.min(end, dominantBand[1])]);
    }

    const nonDomPool = fullPool.filter((i) => i < dominantBand[0] || i > dominantBand[1]);

    const rng = mulberry32(hashStringToU32(seedKey));
    const span = Math.max(1, end - start);
    const basePool =
      positionId === "dark"
        ? [0, 1, 2, 3]
        : positionId === "light"
          ? [7, 8, 9, 10]
          : [4, 5, 6]; // mid baseline: 4–6
    let baseCandidates = basePool.filter((i) => i >= start && i <= end);
    if (baseCandidates.length === 0) {
      const fallback = positionId === "dark" ? start : positionId === "light" ? end : clamp(Math.round((start + end) / 2), start, end);
      baseCandidates = [fallback];
    }
    const baseSet = new Set(baseCandidates);
    const basePrefRng = mulberry32(hashStringToU32(`${seedKey}:basePref`));
    let basePreferred = baseCandidates[Math.floor(basePrefRng() * baseCandidates.length)];
    if (positionId === "light") {
      // Prefer a clearly "bright" background (8–10) but allow 7 for variation.
      const hi = baseCandidates.filter((i) => i >= 8);
      if (hi.length && basePrefRng() < 0.82) basePreferred = hi[Math.floor(basePrefRng() * hi.length)];
    } else if (positionId === "mid") {
      // Prefer the center gray (5) when available.
      if (baseCandidates.includes(5) && basePrefRng() < 0.6) basePreferred = 5;
    }
    const mode = {
      // For mid tones (esp. short), alternate darker/lighter overall to create visible variation.
      midShift: positionId === "mid" ? (rng() < 0.5 ? -0.18 : 0.18) : 0,
      // Encourage accents towards the opposite end for long tones.
      wantOppositeAccent: lengthId === "long",
    };

    const share = lengthId === "short" ? 1 : lengthId === "medium" ? 0.8 : 0.68;
    const maxAccent =
      lengthId === "short" ? 0 : lengthId === "medium" ? Math.max(1, Math.floor(items.length * 0.25)) : Math.max(1, Math.floor(items.length * 0.42));

    const isAccentCandidate = (it) => {
      if (positionId === "light") return it.L < 0.28;
      if (positionId === "dark") return it.L > 0.78;
      return Math.abs(it.L - 0.5) > 0.28;
    };

    const accents = [];
    const bySmall = items.slice().sort((a, b) => a.w - b.w);
    for (const it of bySmall) {
      if (accents.length >= maxAccent) break;
      if (!isAccentCandidate(it)) continue;
      accents.push(it.c);
    }

    const accentSet = new Set(accents);
    let dominantCount = Math.max(1, Math.round(items.length * share));
    dominantCount = clamp(dominantCount, 1, items.length);
    dominantCount = Math.max(dominantCount, items.length - accents.length);

    const dominanceScore = (it) => {
      if (positionId === "light") return it.w * (0.7 + 0.3 * it.L);
      if (positionId === "dark") return it.w * (0.7 + 0.3 * (1 - it.L));
      const mid = 1 - Math.min(1, Math.abs(it.L - 0.5) * 2);
      return it.w * (0.7 + 0.3 * mid);
    };

    const dominantItems = items
      .filter((it) => !accentSet.has(it.c))
      .sort((a, b) => dominanceScore(b) - dominanceScore(a))
      .slice(0, dominantCount)
      .sort((a, b) => a.L - b.L);

    const remaining = items
      .filter((it) => !accentSet.has(it.c) && !dominantItems.some((d) => d.c === it.c))
      .sort((a, b) => a.L - b.L);

    const finalAccents = accents
      .map((c) => items.find((it) => it.c === c))
      .filter(Boolean)
      .sort((a, b) => a.L - b.L);

    const used = new Set();
    const domPickPool = domPool.length ? domPool : fullPool;
    const domIndices = pickSpreadUnique({ pool: domPickPool, count: dominantItems.length, rng, used });

    let accPool = nonDomPool.length ? nonDomPool.slice() : domPickPool.slice();
    if (positionId === "light") accPool.sort((a, b) => a - b);
    else if (positionId === "dark") accPool.sort((a, b) => b - a);
    else accPool.sort((a, b) => Math.abs(b - 5) - Math.abs(a - 5)); // prefer extremes

    const accentIndices = pickSpreadUnique({ pool: accPool, count: finalAccents.length, rng, used });
    const restIndices = pickSpreadUnique({ pool: fullPool, count: remaining.length, rng, used });

    const idxMap = {};
    for (let i = 0; i < dominantItems.length; i++) idxMap[dominantItems[i].c] = domIndices[i] ?? domIndices[domIndices.length - 1];
    for (let i = 0; i < finalAccents.length; i++) idxMap[finalAccents[i].c] = accentIndices[i] ?? accentIndices[accentIndices.length - 1];
    for (let i = 0; i < remaining.length; i++) idxMap[remaining[i].c] = restIndices[i] ?? restIndices[restIndices.length - 1];

    // Global anti-fusion optimization across all lengths:
    // search an assignment that keeps overall "position" feeling correct while:
    // - separating large-area layers
    // - ensuring long tones contain a small opposite-side accent when possible
    // - providing visible variation for mid-short tones (via midShift)
    const roleByColor = {};
    for (const it of dominantItems) roleByColor[it.c] = "dominant";
    for (const it of finalAccents) roleByColor[it.c] = "accent";

    const byColor = {};
    for (const it of items) byColor[it.c] = it;
    const maxW = Math.max(1, ...items.map((x) => x.w || 1));
    const wNorm = {};
    const L = {};
    for (const c of colors) {
      wNorm[c] = (byColor[c]?.w ?? 1) / maxW;
      L[c] = byColor[c]?.L ?? relLuminanceFromHex(c);
    }

    const adjacentPairs = (() => {
      const boxes = bboxInfo?.boxes || {};
      const viewW = bboxInfo?.viewW || 1000;
      const viewH = bboxInfo?.viewH || 1000;
      const pad = Math.max(2, Math.min(viewW, viewH) * 0.016);

      const keys = colors.filter((c) => boxes[c]);
      const set = new Set();
      const expand = (b) => ({ minX: b.minX - pad, minY: b.minY - pad, maxX: b.maxX + pad, maxY: b.maxY + pad });
      const overlapOrClose = (a0, b0) => {
        const a = expand(a0);
        const b = expand(b0);
        const dx = Math.max(0, Math.max(a.minX - b.maxX, b.minX - a.maxX));
        const dy = Math.max(0, Math.max(a.minY - b.maxY, b.minY - a.maxY));
        return dx === 0 && dy === 0;
      };
      for (let i = 0; i < keys.length; i++) {
        const a = keys[i];
        const ba = boxes[a];
        if (!ba) continue;
        for (let j = i + 1; j < keys.length; j++) {
          const b = keys[j];
          const bb = boxes[b];
          if (!bb) continue;
          if (!overlapOrClose(ba, bb)) continue;
          const k = a < b ? `${a}|${b}` : `${b}|${a}`;
          set.add(k);
        }
      }
      return set;
    })();

    const minLColor = colors.reduce((best, c) => (L[c] < L[best] ? c : best), colors[0]);
    const barLayerSet = useTemplateHeuristics ? new Set(BAR_LAYER_PLACEHOLDERS.filter((c) => colors.includes(c))) : new Set();
    const headlineColors = useTemplateHeuristics ? [HEADLINE_PLACEHOLDER_TOP, HEADLINE_PLACEHOLDER_BOTTOM].filter((c) => colors.includes(c)) : [];
    const circleColor = useTemplateHeuristics && colors.includes(CIRCLE_BASE_FILL) ? CIRCLE_BASE_FILL : null;

    const dominantFill = findDominantFillColor(svgText);
    const baseColor = dominantFill && colors.includes(dominantFill) ? dominantFill : colors[0];

    const longAccentPrimaryKey = (() => {
      if (lengthId !== "long") return null;
      const rngOpp = mulberry32(hashStringToU32(`${seedKey}:longAccentPrimary`));

      // Default template: choose among known "clear layers" so the highlight doesn't lock to one place.
      if (useTemplateHeuristics) {
        const candidates = [];
        if (circleColor && circleColor !== baseColor) candidates.push(circleColor);
        for (const c of headlineColors) if (c !== baseColor) candidates.push(c);
        for (const c of barLayerSet) if (c !== baseColor) candidates.push(c);
        const uniq = Array.from(new Set(candidates));
        if (!uniq.length) return null;

        const weights = uniq.map((c) => {
          let w = typeof wNorm[c] === "number" ? wNorm[c] : 0.01;
          if (c === circleColor) w *= 0.45; // circle is huge; keep it "sometimes", not always
          else if (headlineColors.includes(c)) w *= 1.15;
          else if (barLayerSet.has(c)) w *= 0.95;
          w *= 0.8 + rngOpp() * 0.4; // per-cell jitter for variation
          return Math.max(0.0001, w);
        });

        let sum = 0;
        for (const w of weights) sum += w;
        let r = rngOpp() * sum;
        for (let i = 0; i < uniq.length; i++) {
          r -= weights[i];
          if (r <= 0) return uniq[i];
        }
        return uniq[uniq.length - 1] || null;
      }

      // Custom SVG: pick a small-area layer as the "opposite-side carrier" so long tones can
      // actually reach the range ends (e.g. 10 in dark-long), even when original colors are flat.
      const nonBase = colors.filter((c) => c !== baseColor);
      if (!nonBase.length) return null;

      const bySmall = nonBase
        .slice()
        .sort((a, b) => (wNorm[a] ?? 1) - (wNorm[b] ?? 1))
        .slice(0, Math.min(6, nonBase.length));
      const cand = bySmall.length ? bySmall : nonBase;

      const weights = cand.map((c) => {
        const w = typeof wNorm[c] === "number" ? wNorm[c] : 1;
        const inv = 1 / (w + 0.03); // strongly prefer smaller layers
        return Math.max(0.0001, inv * (0.85 + rngOpp() * 0.3));
      });

      let sum = 0;
      for (const w of weights) sum += w;
      let r = rngOpp() * sum;
      for (let i = 0; i < cand.length; i++) {
        r -= weights[i];
        if (r <= 0) return cand[i];
      }
      return cand[cand.length - 1] || null;
    })();

    const pickPoolFor = (c) => {
      if (c === baseColor) return baseCandidates;
      if (lengthId === "long" && longAccentPrimaryKey && c === longAccentPrimaryKey) return fullPool;
      // Treat the bottom-bar layers as dedicated "accent carriers" for long tones so
      // they can reach the opposite side (and avoid locking the accent on the silhouette).
      if (useTemplateHeuristics && lengthId === "long" && BAR_LAYER_PLACEHOLDERS.includes(c)) return accPool.length ? accPool : fullPool;
      // Headline layer may take extreme values in long tones (it is the main highlight candidate).
      if (useTemplateHeuristics && lengthId === "long" && (c === HEADLINE_PLACEHOLDER || c === HEADLINE_PLACEHOLDER_2)) return fullPool;
      const role = roleByColor[c] || "any";
      if (role === "dominant") return domPickPool.length ? domPickPool : fullPool;
      if (role === "accent") return accPool.length ? accPool : fullPool;
      return fullPool;
    };

    const order = colors.slice().sort((a, b) => (wNorm[b] ?? 0) - (wNorm[a] ?? 0));
    if (baseColor) {
      const i = order.indexOf(baseColor);
      if (i > 0) {
        order.splice(i, 1);
        order.unshift(baseColor);
      }
    }
    const pools = {};
    let combos = 1;
    let combosTooBig = false;
    for (const c of order) {
      const p = pickPoolFor(c);
      pools[c] = p;
      if (!combosTooBig) {
        combos *= p.length || 1;
        if (combos > 220000) combosTooBig = true;
      }
    }

    const wFor = (c, fallback) => (typeof wNorm[c] === "number" ? wNorm[c] : fallback);

    const shortTonePref = (() => {
      if (lengthId !== "short") return null;

      const rngShort = mulberry32(hashStringToU32(`${seedKey}:shortPref`));
      const midIdx = clamp(Math.round((start + end) / 2), start, end);

      const nonBase = colors.filter((c) => c !== baseColor);
      if (!nonBase.length) return null;

      const maxLColor = nonBase.reduce((best, c) => (L[c] > L[best] ? c : best), nonBase[0]);
      const darkLayer = minLColor && minLColor !== baseColor ? minLColor : null;

      const brightSet = new Set();
      if (circleColor && circleColor !== baseColor) brightSet.add(circleColor);
      for (const c of headlineColors) if (c !== baseColor) brightSet.add(c);
      for (const c of barLayerSet) if (c !== baseColor) brightSet.add(c);
      if (maxLColor && maxLColor !== baseColor) brightSet.add(maxLColor);
      const brightChoices = Array.from(brightSet).filter((c) => colors.includes(c) && c !== baseColor);

      const fallbackChoices = order.filter((c) => c !== baseColor).slice(0, 6);
      const pickFrom = (arr) => arr[Math.floor(rngShort() * arr.length)];

      const brightLayer = (brightChoices.length ? pickFrom(brightChoices) : pickFrom(fallbackChoices)) || null;
      const midChoices = (brightChoices.length ? brightChoices : fallbackChoices).filter((c) => c && c !== brightLayer && c !== baseColor);
      let midLayer = (midChoices.length ? pickFrom(midChoices) : null) || null;

      // Ensure we have 3 distinct layers when possible.
      if (midLayer === darkLayer) midLayer = null;
      const alt = fallbackChoices.find((c) => c !== baseColor && c !== darkLayer && c !== brightLayer) || null;
      if (!midLayer && alt) midLayer = alt;

      const keyColors = [darkLayer, midLayer, brightLayer].filter(Boolean);
      const uniqKeys = Array.from(new Set(keyColors)).filter((c) => c !== baseColor);
      if (!uniqKeys.length) return null;

      // Assign preferences: dark layer -> start, bright layer -> end, mid layer -> mid.
      // Add some variation by occasionally swapping which bright-candidate layer gets end vs mid.
      const prefByColor = {};
      if (darkLayer) prefByColor[darkLayer] = start;
      if (brightLayer) prefByColor[brightLayer] = end;
      if (midLayer) prefByColor[midLayer] = midIdx;
      if (brightLayer && midLayer && rngShort() < 0.35) {
        prefByColor[brightLayer] = midIdx;
        prefByColor[midLayer] = end;
      }

      return { prefByColor, keyColors: uniqKeys, startIdx: start, midIdx, endIdx: end };
    })();

      const longAccentCfg = (() => {
        if (lengthId !== "long") return null;
        const rngOpp = mulberry32(hashStringToU32(`${seedKey}:longAccent`));

        if (!useTemplateHeuristics) {
          const nonBase = order.filter((c) => c !== baseColor);
          const bySmall = nonBase.slice().sort((a, b) => wFor(a, 0.01) - wFor(b, 0.01));
          const targets = bySmall.slice(0, Math.min(4, bySmall.length));
          if (!targets.length) return null;
          const primary = (longAccentPrimaryKey && targets.includes(longAccentPrimaryKey) ? longAccentPrimaryKey : null) || targets[Math.floor(rngOpp() * targets.length)];

          if (positionId === "dark") {
            const preferred = rngOpp() < 0.65 ? (rngOpp() < 0.5 ? 10 : 9) : rngOpp() < 0.5 ? 8 : 7;
            return { targets, primary, preferred, brightBand: [7, 10], barLayers: [] };
          }
          if (positionId === "light") {
            const r = rngOpp();
            const preferred = r < 0.6 ? (r < 0.3 ? 0 : 1) : r < 0.8 ? 2 : 3;
            return { targets, primary, preferred, darkBand: [0, 3], barLayers: [] };
          }
          const preferredLow = rngOpp() < 0.5 ? 1 : 2;
          const preferredHigh = rngOpp() < 0.5 ? 9 : 8;
          return { targets, primary, preferredLow, preferredHigh, darkBand: [0, 3], brightBand: [7, 10], barLayers: [] };
        }

        const targets = [];
        // Allow the "opposite-side" accent to land on ANY clear layer (circle / headline lines / bottom bars),
        // so we get richer combinations and avoid a fixed "bars always bright" look.
        if (circleColor && circleColor !== baseColor) targets.push(circleColor);
        for (const c of headlineColors) if (c !== baseColor) targets.push(c);
        for (const c of barLayerSet) if (c !== baseColor) targets.push(c);
        const uniqTargets = Array.from(new Set(targets));
        if (!uniqTargets.length) return null;

        const barLayers = Array.from(barLayerSet);
        const primary =
          (longAccentPrimaryKey && uniqTargets.includes(longAccentPrimaryKey) ? longAccentPrimaryKey : null) || uniqTargets[Math.floor(rngOpp() * uniqTargets.length)];

        if (positionId === "dark") {
          const preferred = rngOpp() < 0.62 ? (rngOpp() < 0.5 ? 10 : 9) : rngOpp() < 0.5 ? 8 : 7;
          return { targets: uniqTargets, primary, preferred, brightBand: [7, 10], barLayers };
        }
        if (positionId === "light") {
          const r = rngOpp();
          const preferred = r < 0.55 ? (r < 0.275 ? 0 : 1) : r < 0.775 ? 2 : 3;
          return { targets: uniqTargets, primary, preferred, darkBand: [0, 3], barLayers };
        }

        // mid: require both sides; pick preferred indices on each side.
        const preferredLow = rngOpp() < 0.5 ? 1 : 2;
        const preferredHigh = rngOpp() < 0.5 ? 9 : 8;
        return { targets: uniqTargets, primary, preferredLow, preferredHigh, darkBand: [0, 3], brightBand: [7, 10], barLayers };
      })();

    const scoreAssignment = (assign) => {
      let score = 0;
      // Lower threshold to include more small details in collision checks (was 0.008)
      const scoreOrderRaw = order.filter((c) => (wNorm[c] ?? 0) > 0.001);
      const scoreOrder = scoreOrderRaw.length >= 2 ? scoreOrderRaw : order;

      // Short tones have only 3 values; add a gentle per-card preference so the mapping
      // doesn't collapse into the same look every time (especially mid/light short).
      if (shortTonePref) {
        const used = new Set();
        for (const c of shortTonePref.keyColors) {
          const idx = assign[c];
          used.add(idx);
          const pref = shortTonePref.prefByColor[c];
          if (typeof pref === "number") {
            const w = wFor(c, 0.15);
            score += idx === pref ? 70 * (0.25 + w) : -18 * (0.25 + w);
          }
        }

        if (shortTonePref.keyColors.length >= 2) {
          const hasEnds = used.has(shortTonePref.startIdx) && used.has(shortTonePref.endIdx);
          score += hasEnds ? 90 : -140;
          if (used.size >= 3) score += 70;
          else if (used.size === 2) score += 18;
          else score -= 120;
        }
      }

      // Overall mean (area-weighted) should match position impression.
      const sumW = scoreOrder.reduce((acc, c) => acc + wFor(c, 0.2), 0) || 1;
      const mean = scoreOrder.reduce((acc, c) => acc + assign[c] * wFor(c, 0.2), 0) / sumW;
      const target = clamp(basePreferred + mode.midShift * span, start, end);
      score -= Math.abs(mean - target) * (lengthId === "short" ? 26 : lengthId === "medium" ? 22 : 16);

      // Force the true largest-area layer (background) to be in the baseline pool.
      const baseIdx = assign[baseColor];
      const baseW = wFor(baseColor, 0.4);
      if (baseSet.has(baseIdx)) score += 160 * (0.5 + baseW);
      else score -= 520 * (0.5 + baseW);
      if (baseIdx === basePreferred) score += 14;

      // Hard anti-fusion constraints for key layers (applies to ALL tones, not per-tone special cases):
      // - bars / circle / headline should not collapse into the background
      // - for medium/long, prefer >= 2 steps difference for major adjacent visual masses
      if (circleColor) {
        const cIdx = assign[circleColor];
        const d = Math.abs(cIdx - baseIdx);
        if (d === 0) score -= 520;
        else if (lengthId !== "short" && d < 2) score -= 220;
      }

      if (barLayerSet.size) {
        const barIdxs = [];
        for (const c of barLayerSet) {
          const idx = assign[c];
          barIdxs.push(idx);
          const d = Math.abs(idx - baseIdx);
          if (d === 0) score -= 520;
          else if (lengthId !== "short" && d < 2) score -= 180;
          if (circleColor) {
            const dc = Math.abs(idx - assign[circleColor]);
            if (dc === 0) score -= 260;
          }
        }
        if (barIdxs.length >= 2) {
          const uniq = new Set(barIdxs).size;
          if (uniq === 1) score -= 260; // bars disappearing into each other is very visible
        }
      }

      if (headlineColors.length) {
        const hIdxs = headlineColors.map((c) => assign[c]);
        for (const idx of hIdxs) {
          const d = Math.abs(idx - baseIdx);
          if (d === 0) score -= 520;
        }
        if (headlineColors.length >= 2) {
          const d = Math.abs(hIdxs[0] - hIdxs[1]);
          // Don't force them always different, but prevent identical (it collapses into one flat block).
          if (d === 0) score -= 180;
        }
      }

      // Keep the overall "position" feeling: top large-area layers should mostly live in the position group.
      const [g0, g1] = dominantGroupFor(positionId);
      const major = scoreOrder.slice(0, Math.min(3, scoreOrder.length));
      if (lengthId === "long") {
        // Long tones: keep the base/background in the position group, while allowing:
        // - the 2nd-largest layer to stay near the group (so the picture still reads as dark/gray/bright)
        // - the 3rd-largest layer to become a true opposite-side highlight (often the title text)
        //
        // This avoids a fixed "highlight always on the silhouette" pattern.
        const majorNonBase = major.filter((c) => c !== baseColor);
        const second = majorNonBase[0] || null;
        // Consider both headline layers as candidates for the highlight role, but prefer the
        // per-card "accent carrier" so the highlight doesn't get locked to one layer.
        const preferHeadline = useTemplateHeuristics ? majorNonBase.find((c) => c === HEADLINE_PLACEHOLDER || c === HEADLINE_PLACEHOLDER_2) || null : null;
        const highlight =
          (longAccentCfg?.primary && longAccentCfg.primary !== baseColor ? longAccentCfg.primary : null) ||
          preferHeadline ||
          majorNonBase.find((c) => c !== second) ||
          null;

        // Still prefer the base/background to be inside the group (base pool already enforces this harder).
        for (const c of major) {
          const idx = assign[c];
          const w = wFor(c, 0.2);
          const inGroup = idx >= g0 && idx <= g1;
          score += inGroup ? 10 * (0.2 + w) : -10 * (0.2 + w);
        }

        const countVeryBright = major.filter((c) => (assign[c] ?? 0) >= 8).length;
        const countVeryDark = major.filter((c) => (assign[c] ?? 10) <= 2).length;

        if (positionId === "dark") {
          if (second) {
            const idx = assign[second];
            const w = wFor(second, 0.2);
            // The 2nd-largest layer normally shouldn't become "bright" (it flips the overall feel),
            // but allow it when it is the chosen "accent carrier" (e.g. the big circle).
            if (second === highlight) {
              if (idx >= 8) score += 70 * (0.25 + w);
              else score -= 120 * (0.25 + w);
            } else {
              if (idx >= 8) score -= 260 * (0.25 + w);
              else if (idx <= 6) score += 28 * (0.25 + w);
            }
          }
          if (highlight) {
            const idx = assign[highlight];
            const w = wFor(highlight, 0.2);
            // Require a true bright highlight for long-dark; otherwise it reads like a medium tone.
            if (idx >= 10) score += 320 * (0.25 + w);
            else if (idx >= 9) score += 280 * (0.25 + w);
            else if (idx >= 8) score += 160 * (0.25 + w);
            else score -= 520 * (0.25 + w);
          }
          if (countVeryBright >= 2) score -= 180;
        } else if (positionId === "light") {
          if (second) {
            const idx = assign[second];
            const w = wFor(second, 0.2);
            // The 2nd-largest layer normally shouldn't become "dark",
            // but allow it when it is the chosen "accent carrier" (e.g. the big circle).
            if (second === highlight) {
              if (idx <= 2) score += 70 * (0.25 + w);
              else score -= 120 * (0.25 + w);
            } else {
              if (idx <= 2) score -= 260 * (0.25 + w);
              else if (idx >= 4) score += 28 * (0.25 + w);
            }
          }
          if (highlight) {
            const idx = assign[highlight];
            const w = wFor(highlight, 0.2);
            // Require a true dark highlight for long-light; otherwise it reads like a medium tone.
            if (idx <= 0) score += 320 * (0.25 + w);
            else if (idx <= 1) score += 280 * (0.25 + w);
            else if (idx <= 2) score += 160 * (0.25 + w);
            else score -= 520 * (0.25 + w);
          }
          if (countVeryDark >= 2) score -= 180;
        } else {
          // mid
          if (second) {
            const idx = assign[second];
            const w = wFor(second, 0.2);
            if (idx <= 2 || idx >= 8) score -= 140 * (0.25 + w);
            else if (idx >= 4 && idx <= 7) score += 22 * (0.25 + w);
          }
          if (highlight) {
            const idx = assign[highlight];
            const w = wFor(highlight, 0.2);
            // Mid-long still benefits from a clear dark/bright accent on a major layer.
            if (idx <= 0 || idx >= 10) score += 240 * (0.25 + w);
            else if (idx <= 1 || idx >= 9) score += 200 * (0.25 + w);
            else if (idx <= 2 || idx >= 8) score += 120 * (0.25 + w);
            else score -= 360 * (0.25 + w);
          }
          if (countVeryBright >= 2 || countVeryDark >= 2) score -= 140;
        }
      } else {
        for (const c of major) {
          const idx = assign[c];
          const w = wFor(c, 0.2);
          const inGroup = idx >= g0 && idx <= g1;
          score += inGroup ? 26 * (0.25 + w) : -120 * (0.35 + w);
        }
      }

      // Penalize merging of big layers; encourage spread among top 3.
      const top3 = scoreOrder.slice(0, 3).filter(Boolean);
      if (top3.length >= 2) {
        const idxs = top3.map((c) => assign[c]);
        const uniq = new Set(idxs).size;
        score += (uniq - 1) * 10;
        score += (Math.max(...idxs) - Math.min(...idxs)) * 8.5;

        // For medium/long, ensure the biggest layers don't sit on adjacent levels (too easy to "melt" together).
        if (lengthId !== "short") {
          for (let i = 0; i < top3.length; i++) {
            for (let j = i + 1; j < top3.length; j++) {
              const a = top3[i];
              const b = top3[j];
              const d = Math.abs(assign[a] - assign[b]);
              if (d < 2) score -= 260 * (0.45 + wFor(a, 0.2) * wFor(b, 0.2));
            }
          }
        }
      }

      // Extra anti-fusion: include the 4th largest layer for medium/short, where the range is tighter and fusion is common.
      if (lengthId !== "long") {
        const top4 = scoreOrder.slice(0, 4).filter(Boolean);
        if (top4.length >= 2) {
          for (let i = 0; i < top4.length; i++) {
            for (let j = i + 1; j < top4.length; j++) {
              const a = top4[i];
              const b = top4[j];
              const d = Math.abs(assign[a] - assign[b]);
              const wpair = wFor(a, 0.2) * wFor(b, 0.2);
              if (d === 0) score -= 220 * (0.25 + wpair);
              else if (d === 1) score -= 140 * (0.25 + wpair);
              else if (d === 2) score += 10 * (0.25 + wpair);
            }
          }
        }
      }

      for (let i = 0; i < scoreOrder.length; i++) {
        for (let j = i + 1; j < scoreOrder.length; j++) {
          const a = scoreOrder[i];
          const b = scoreOrder[j];
          const ia = assign[a];
          const ib = assign[b];
          const wa = wFor(a, 0.2);
          const wb = wFor(b, 0.2);
          const wpair = wa * wb;
          const d = Math.abs(ia - ib);
          
          // Calculate original luminance difference.
          // If original colors had high contrast, we MUST preserve it.
          const ld = Math.abs(L[a] - L[b]);
          
          // Importance factor: combines area weight and original contrast.
          // We care more about preserving contrast for large areas and originally high-contrast pairs.
          const importance = (0.25 + wpair) * (0.5 + ld * 1.5);

          // Prioritize preventing "fusion" where the shapes are likely adjacent in the image.
          const k = a < b ? `${a}|${b}` : `${b}|${a}`;
          const isAdjacent = adjacentPairs.has(k);
          const adjMul = isAdjacent ? 1 : 0.35;

          if (d === 0) {
            // Fusion: two different original colors mapped to the exact same level.
            // Catastrophic if they were originally high contrast.
            score -= 1500 * importance * adjMul;
          } else if (d === 1) {
            // Adjacent: too close, low contrast.
            // Bad if they were originally high contrast.
            score -= 250 * importance * adjMul;
          } else {
            // Good separation.
            score += Math.min(d, 5) * 8 * importance * adjMul;
          }

          // Maintain relative order logic (soft constraint).
          if (ld > 0.2) {
            const should = L[a] < L[b] ? ia <= ib : ia >= ib;
            // If the order is inverted compared to original, penalize.
            if (!should) score -= 15 * (ld - 0.1) * (0.5 + wpair) * (isAdjacent ? 1 : 0.55);
          }
        }
      }

      // Long tones: ensure the "opposite side" shows up via small layers (not fixed on the silhouette).
      if (lengthId === "long" && longAccentCfg?.targets?.length) {
        const targets = longAccentCfg.targets;
        const primary = longAccentCfg.primary;

        if (positionId === "dark") {
          const accentCount = targets.reduce((acc, c) => acc + ((assign[c] ?? 0) >= 7 ? 1 : 0), 0);
          const veryCount = targets.reduce((acc, c) => acc + ((assign[c] ?? 0) >= 9 ? 1 : 0), 0);
          score += accentCount >= 1 ? 240 : -420;
          score += veryCount >= 1 ? 80 : -80;

          const pIdx = assign[primary];
          const pIsAccent = (pIdx ?? 0) >= 7;
          score += pIsAccent ? 90 : -120;
          if (typeof longAccentCfg.preferred === "number") score += pIdx === longAccentCfg.preferred ? 26 : 0;

          // Prefer a single "bright carrier": if the circle becomes bright, the headline/bars don't need to.
          const extra = useTemplateHeuristics && primary === circleColor ? 40 : 0;
          const extraBright = Math.max(0, accentCount - (pIsAccent ? 1 : 0));
          const penalty = (useTemplateHeuristics ? 140 : 70) + extra;
          score -= penalty * extraBright;
        } else if (positionId === "light") {
          const accentCount = targets.reduce((acc, c) => acc + ((assign[c] ?? 99) <= 3 ? 1 : 0), 0);
          const veryCount = targets.reduce((acc, c) => acc + ((assign[c] ?? 99) <= 1 ? 1 : 0), 0);
          score += accentCount >= 1 ? 240 : -420;
          score += veryCount >= 1 ? 80 : -80;

          const pIdx = assign[primary];
          const pIsAccent = (pIdx ?? 99) <= 3;
          score += pIsAccent ? 90 : -120;
          if (typeof longAccentCfg.preferred === "number") score += pIdx === longAccentCfg.preferred ? 26 : 0;

          // Prefer a single "dark carrier": if the circle becomes dark, the headline/bars don't need to.
          const extra = useTemplateHeuristics && primary === circleColor ? 40 : 0;
          const extraDark = Math.max(0, accentCount - (pIsAccent ? 1 : 0));
          const penalty = (useTemplateHeuristics ? 140 : 70) + extra;
          score -= penalty * extraDark;
        } else if (positionId === "mid") {
          const hasDark = targets.some((c) => assign[c] <= 3);
          const hasBright = targets.some((c) => assign[c] >= 7);
          score += hasDark ? 180 : -260;
          score += hasBright ? 180 : -260;

          const pIdx = assign[primary];
          const inEither = pIdx <= 3 || pIdx >= 7;
          score += inEither ? 24 : -24;
          if (typeof longAccentCfg.preferredLow === "number" && pIdx === longAccentCfg.preferredLow) score += 14;
          if (typeof longAccentCfg.preferredHigh === "number" && pIdx === longAccentCfg.preferredHigh) score += 14;
        }
      }

      // Avoid locking the darkest shape to the absolute darkest value when a clear small-area dark accent already exists.
      if (lengthId === "long" && positionId === "light" && barLayerSet.size) {
        let barHasDark = false;
        for (const c of barLayerSet) {
          if ((assign[c] ?? 99) <= 3) {
            barHasDark = true;
            break;
          }
        }
        if (barHasDark) {
          const idx = assign[minLColor];
          if (idx <= 1) score -= 96;
          else if (idx <= 3) score += 12;
        }
      }

      // Prefer using range ends (helps short/medium feel less flat).
      const usedIdx = scoreOrder.map((c) => assign[c]);
      score += new Set(usedIdx).size * 2.2;
      if (usedIdx.includes(start)) score += 2.2;
      if (usedIdx.includes(end)) score += 2.2;

      // Encourage richer layer variety (soft targets; never override anti-fusion / base tone).
      {
        const uniqCount = new Set(usedIdx).size;
        const maxPossible = end - start + 1;
        if (lengthId === "long") {
          const targetUniq = Math.min(8, maxPossible);
          if (uniqCount < targetUniq) score -= (targetUniq - uniqCount) * 42;
          else score += 10;
        } else if (lengthId === "medium") {
          const targetUniq = Math.min(5, maxPossible);
          if (uniqCount < targetUniq) score -= (targetUniq - uniqCount) * 60;
          else score += 6;
        } else if (lengthId === "short") {
          const targetUniq = Math.min(3, maxPossible);
          if (uniqCount < targetUniq) score -= (targetUniq - uniqCount) * 120;
          else score += 6;
        }
      }

      // Extra: for mid-short specifically, strongly encourage using both ends (4 and 6) to avoid "all gray".
      if (positionId === "mid" && lengthId === "short") {
        if (usedIdx.includes(start) && usedIdx.includes(end)) score += 14;
        else score -= 14;
      }

      // Deterministic micro-noise to break ties (prevents repeatedly converging to the same assignment).
      // Scale is tiny compared to other terms: it only affects near-equal scores.
      {
        let h = hashStringToU32(`${seedKey}:tie`);
        for (const c of order) {
          const v = assign[c] ?? 0;
          h ^= (hashStringToU32(c) + v * 131) >>> 0;
          h = Math.imul(h, 16777619) >>> 0;
        }
        score += (h / 4294967296) * 0.25;
      }
      return score;
    };

    const initialAssign = {};
    for (const c of colors) initialAssign[c] = typeof idxMap[c] === "number" ? idxMap[c] : clamp(Math.round((start + end) / 2), start, end);

    let bestAssign = null;
    let bestScore = -Infinity;

    const consider = (assign) => {
      const s = scoreAssignment(assign);
      if (s > bestScore) {
        bestScore = s;
        bestAssign = { ...assign };
      }
    };

    // Always consider the heuristic initial assignment.
    consider(initialAssign);

    if (!combosTooBig) {
      // Exhaustive search (bounded by combos threshold).
      const assign = {};
      const rec = (i) => {
        if (i >= order.length) {
          consider(assign);
          return;
        }
        const c = order[i];
        const p = pools[c] || fullPool;
        for (let k = 0; k < p.length; k++) {
          assign[c] = p[k];
          rec(i + 1);
        }
      };
      rec(0);
    } else {
      // Random search for larger combinations (seeded, deterministic per cell).
      const rngSearch = mulberry32(hashStringToU32(`${seedKey}:search`));
      const assign = {};
      for (const c of order) {
        const p = pools[c] || fullPool;
        const want = initialAssign[c];
        assign[c] = p.includes(want) ? want : p[Math.floor(rngSearch() * p.length)];
      }
      consider(assign);

      const SAMPLES = 2600;
      for (let i = 0; i < SAMPLES; i++) {
        for (const c of order) {
          const p = pools[c] || fullPool;
          assign[c] = p[Math.floor(rngSearch() * p.length)];
        }
        consider(assign);
      }

      // Greedy polish around the best candidate.
      if (bestAssign) {
        for (let pass = 0; pass < 2; pass++) {
          for (const c of order) {
            const p = pools[c] || fullPool;
            let localBest = bestScore;
            let localIdx = bestAssign[c];
            for (let k = 0; k < p.length; k++) {
              const candidate = { ...bestAssign, [c]: p[k] };
              const s = scoreAssignment(candidate);
              if (s > localBest) {
                localBest = s;
                localIdx = p[k];
              }
            }
            if (localBest > bestScore) {
              bestScore = localBest;
              bestAssign[c] = localIdx;
            }
          }
        }
      }
    }

    const finalAssign = bestAssign || initialAssign;

    const usedIndicesSet = new Set();
    const indexWeights = {};
    for (const c of colors) {
      const idx = finalAssign[c] ?? clamp(Math.round((start + end) / 2), start, end);
      usedIndicesSet.add(idx);
      indexWeights[idx] = (indexWeights[idx] || 0) + (wNorm[c] ?? 0.001);
    }
    const usedIndices = Array.from(usedIndicesSet).sort((a, b) => a - b);
    if (typeof onAssignment === "function") {
      try {
        onAssignment({
          assignment: finalAssign,
          usedIndices,
          indexWeights,
          baseColor,
        });
      } catch (e) {
        console.warn("[levels-tones] onAssignment failed:", e);
      }
    }

    const toColor = typeof indexToColor === "function" ? indexToColor : (idx) => LEVELS[clamp(idx, 0, 10)];
    const map = {};
    for (const c of colors) {
      const idx = finalAssign[c] ?? clamp(Math.round((start + end) / 2), start, end);
      const meta = { originalColor: c, role: roleByColor[c] || "any", weight: wNorm[c] ?? 0 };
      map[c] = toColor(idx, meta);
    }
    return map;
  }

  function computeIndexMapping({ colorsSorted, start, end }) {
    const n = colorsSorted.length;
    if (n === 0) return [];
    if (n === 1) return [clamp(Math.round((start + end) / 2), start, end)];
    const span = end - start;
    const indices = [];
    for (let i = 0; i < n; i++) {
      const t = i / (n - 1);
      indices.push(clamp(Math.round(start + t * span), start, end));
    }

    // Enforce monotonic non-decreasing.
    for (let i = 1; i < indices.length; i++) indices[i] = Math.max(indices[i], indices[i - 1]);

    // If we have room, try to make them strictly increasing.
    if (span >= n - 1) {
      for (let i = 1; i < indices.length; i++) indices[i] = Math.max(indices[i], indices[i - 1] + 1);
      for (let i = indices.length - 2; i >= 0; i--) indices[i] = Math.min(indices[i], indices[i + 1] - 1);
      indices[0] = Math.max(indices[0], start);
      indices[indices.length - 1] = Math.min(indices[indices.length - 1], end);
    }
    return indices.map((x) => clamp(x, start, end));
  }

  function applyColorMap(svgText, colorMap) {
    if (!colorMap || Object.keys(colorMap).length === 0) return svgText;
    const out = svgText.replace(/#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})\b/g, (m) => {
      const norm = normalizeHex(m);
      return colorMap[norm] || m;
    });
    return out.replace(/\b(fill|stroke)="(white|black)"/gi, (m, attr, name) => {
      const norm = name.toLowerCase() === "white" ? "#FFFFFF" : "#000000";
      const mapped = colorMap[norm];
      if (!mapped) return m;
      return `${attr}="${mapped}"`;
    });
  }

  function uniquifySvgIds(svgText, uid) {
    const ids = [];
    const idRe = /\bid="([^"]+)"/g;
    let m;
    while ((m = idRe.exec(svgText))) ids.push(m[1]);
    if (ids.length === 0) return svgText;

    let out = svgText;
    for (const id of ids) {
      const next = `${id}-${uid}`;
      out = out.replace(new RegExp(`\\bid="${escapeRegExp(id)}"`, "g"), `id="${next}"`);
    }

    for (const id of ids) {
      const next = `${id}-${uid}`;
      out = out.replace(new RegExp(`url\\(#${escapeRegExp(id)}\\)`, "g"), `url(#${next})`);
      out = out.replace(new RegExp(`([\"'])#${escapeRegExp(id)}\\1`, "g"), (m0, q) => `${q}#${next}${q}`);
      out = out.replace(new RegExp(`\\b(xlink:href|href)=\"#${escapeRegExp(id)}\"`, "g"), (m0, attr) => `${attr}="#${next}"`);
    }

    return out;
  }

  function normalizeTemplateSvgRoot(svgText) {
    return svgText.replace(/<svg\b([^>]*)>/, (m, attrs) => {
      let a = attrs;
      a = a.replace(/\swidth="[^"]*"/g, "");
      a = a.replace(/\sheight="[^"]*"/g, "");
      if (/\bclass=/.test(a)) a = a.replace(/\bclass="([^"]*)"/, (mm, cls) => `class="${cls} lt-cover"`);
      else a += ` class="lt-cover"`;
      if (!/\bpreserveAspectRatio=/.test(a)) a += ` preserveAspectRatio="xMidYMid meet"`;
      return `<svg${a}>`;
    });
  }

  function splitTemplateLayerColors(svgText) {
    let hidden = null;
    try {
      const doc = new DOMParser().parseFromString(svgText, "image/svg+xml");
      const parsedRoot = doc.documentElement;
      if (!parsedRoot) return svgText;

      // Use a live SVG element so `getBBox()` works reliably; this makes the headline split
      // robust (no path-data parsing heuristics).
      const liveWrap = document.createElement("div");
      liveWrap.innerHTML = parsedRoot.outerHTML || svgText;
      const root = liveWrap.querySelector("svg");
      if (!root) return parsedRoot.outerHTML || svgText;

      hidden = document.createElement("div");
      hidden.style.cssText = "position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;overflow:hidden;opacity:0;pointer-events:none;";
      hidden.appendChild(root);
      document.body.appendChild(hidden);

      const vb = String(root.getAttribute("viewBox") || "")
        .trim()
        .split(/\s+/)
        .map(parseSvgNumber)
        .filter((x) => x != null);
      const viewW = vb.length === 4 ? vb[2] : parseSvgNumber(root.getAttribute("width")) || 1014;
      const viewH = vb.length === 4 ? vb[3] : parseSvgNumber(root.getAttribute("height")) || 1306;

      // The source template uses the same fill for the big circle and the bottom bars.
      // We split the bottom bars into unique placeholder colors so long-tone accents can
      // land on small areas (instead of always on the silhouette).
      const barRects = [];
      for (const el of root.querySelectorAll("rect")) {
        if (isInNonRenderedContainer(el) || isVisuallyHidden(el)) continue;
        const fill = parseColorToHex(el.getAttribute("fill")) ?? (() => {
          const style = String(el.getAttribute("style") || "");
          const mFill = style ? /\bfill\s*:\s*([^;]+)/i.exec(style) : null;
          return parseColorToHex(mFill?.[1]);
        })();
        if (fill !== CIRCLE_BASE_FILL) continue;

        const w = parseSvgNumber(el.getAttribute("width")) ?? 0;
        const h = parseSvgNumber(el.getAttribute("height")) ?? 0;
        const x = parseSvgNumber(el.getAttribute("x")) ?? 0;
        const y = parseSvgNumber(el.getAttribute("y")) ?? 0;

        // Filter down to "bottom bar" rectangles:
        // - not full canvas
        // - fairly wide but short
        // - near the bottom of the cover
        const isFull = w >= viewW * 0.9 && h >= viewH * 0.9;
        if (isFull) continue;
        const isBar = w >= viewW * 0.35 && w <= viewW * 0.95 && h > 0 && h <= viewH * 0.12;
        const isBottom = y >= viewH * 0.72;
        if (!isBar || !isBottom) continue;
        barRects.push({ el, y, x, w, h });
      }

      barRects.sort((a, b) => a.y - b.y || a.x - b.x || a.w - b.w || a.h - b.h);
      if (barRects.length) {
        for (let i = 0; i < Math.min(barRects.length, BAR_LAYER_PLACEHOLDERS.length); i++) {
          barRects[i].el.setAttribute("fill", BAR_LAYER_PLACEHOLDERS[i]);
        }
      }

      // Split the top headline text into its own layers (two lines), so:
      // - each line stays internally consistent
      // - line 1 and line 2 can differ (learning-friendly)
      // The template uses #BEBEBE for many paths; we detect headline-like paths by vertical bbox.
      const headlineCandidates = [];
      for (const el of root.querySelectorAll("path")) {
        if (isInNonRenderedContainer(el) || isVisuallyHidden(el)) continue;

        const directFill = parseColorToHex(el.getAttribute("fill"));
        const style = String(el.getAttribute("style") || "");
        const mFill = style ? /\bfill\s*:\s*([^;]+)/i.exec(style) : null;
        const styleFill = parseColorToHex(mFill?.[1]);
        const fill = styleFill ?? directFill;
        if (fill !== "#BEBEBE") continue;

        let bb;
        try {
          bb = el.getBBox();
        } catch {
          bb = null;
        }
        if (!bb || !Number.isFinite(bb.y) || !Number.isFinite(bb.height)) continue;
        const maxY = bb.y + bb.height;
        const isHeadline = maxY <= viewH * 0.28; // ~ top 28% of the cover
        if (!isHeadline) continue;
        headlineCandidates.push({ el, midY: bb.y + bb.height / 2 });
      }

      if (headlineCandidates.length > 0) {
        // Split into two lines by finding the largest gap between sorted midY values.
        const mids = headlineCandidates.map((p) => p.midY).slice().sort((a, b) => a - b);
        let threshold = mids.reduce((a, b) => a + b, 0) / mids.length;
        if (mids.length >= 2) {
          let bestGap = -Infinity;
          let bestIdx = -1;
          for (let i = 0; i < mids.length - 1; i++) {
            const gap = mids[i + 1] - mids[i];
            if (gap > bestGap) {
              bestGap = gap;
              bestIdx = i;
            }
          }
          if (bestIdx >= 0) threshold = (mids[bestIdx] + mids[bestIdx + 1]) / 2;
        }
        for (const p of headlineCandidates) {
          // Make the whole line share one fill so it behaves as a single layer:
          // - "SHERLOCK" (top line) becomes one layer
          // - "HOLMES" (bottom line) becomes one layer
          p.el.setAttribute("fill", p.midY <= threshold ? HEADLINE_PLACEHOLDER_TOP : HEADLINE_PLACEHOLDER_BOTTOM);
        }
      }

      return root.outerHTML || svgText;
    } catch {
      return svgText;
    } finally {
      try {
        hidden?.remove();
      } catch {}
    }
  }

  function recolorTemplateSvg({ svgText, range, uid, positionId, lengthId, seed, templateMode = "default", colorSpec, onInfo }) {
    const normalized = normalizeTemplateSvgRoot(svgText);
    const layered = templateMode === "default" ? splitTemplateLayerColors(normalized) : normalized;
    const uniqIds = uniquifySvgIds(layered, uid);
    const colors = extractHexColors(uniqIds);
    if (!colors.length) throw new Error("SVG 中未识别到可变色图层（建议使用 #RRGGBB / white / black）。");

    const seedKey = `${seed}:${uid}:${positionId}:${lengthId}:map`;
    const spec = colorSpec && typeof colorSpec === "object" ? colorSpec : null;

    const shuffleInPlace = (arr, rng) => {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        const t = arr[i];
        arr[i] = arr[j];
        arr[j] = t;
      }
      return arr;
    };

    const pickWeightedUnique = ({ pool, count, rng, weightOf }) => {
      const src = pool.slice();
      const out = [];
      const want = Math.max(0, Math.min(count, src.length));
      for (let i = 0; i < want; i++) {
        let total = 0;
        const w = new Array(src.length);
        for (let k = 0; k < src.length; k++) {
          const wk = Math.max(0, Number(weightOf(src[k])) || 0);
          w[k] = wk;
          total += wk;
        }
        if (total <= 0) {
          out.push(src.shift());
          continue;
        }
        let r = rng() * total;
        let pickIdx = 0;
        for (let k = 0; k < w.length; k++) {
          r -= w[k];
          if (r <= 0) {
            pickIdx = k;
            break;
          }
        }
        out.push(src.splice(pickIdx, 1)[0]);
      }
      return out;
    };

    let huePlan = null;
    let lastInfo = null;
    const onAssignment = (info) => {
      lastInfo = info;
      if (!spec || typeof spec.h !== "number" || typeof spec.s !== "number" || typeof spec.b !== "number") return;

      const baseHue = wrapHue(clamp(spec.h, 0, 360));
      const harmony = typeof spec.harmony === "string" ? spec.harmony : "complement";
      const rel = harmonyHues(baseHue, harmony).map((h) => wrapHue(h));
      const hues = (() => {
        const uniq = [];
        const seen = new Set();
        for (const h of [baseHue, ...rel]) {
          const k = String(wrapHue(h));
          if (seen.has(k)) continue;
          seen.add(k);
          uniq.push(wrapHue(h));
        }
        return uniq;
      })();

      const usedIndices = Array.isArray(info?.usedIndices) ? info.usedIndices.slice() : [];
      if (!usedIndices.length) return;

      let baseIdx =
        typeof info?.baseColor === "string" && info.assignment && typeof info.assignment[info.baseColor] === "number" ? info.assignment[info.baseColor] : null;
      if (typeof baseIdx !== "number" || !usedIndices.includes(baseIdx)) {
        const idxByWeight = usedIndices
          .slice()
          .sort((a, b) => (info?.indexWeights?.[b] ?? 0) - (info?.indexWeights?.[a] ?? 0))
          .at(0);
        baseIdx = typeof idxByWeight === "number" ? idxByWeight : usedIndices[0];
      }

      const need = Math.max(0, Math.min(hues.length - 1, usedIndices.length - 1));
      const candidates = usedIndices.filter((i) => i !== baseIdx);
      const rngPick = mulberry32(hashStringToU32(`${seedKey}:huePlan:${harmony}:pick`));
      const picked = pickWeightedUnique({
        pool: candidates,
        count: need,
        rng: rngPick,
        weightOf: (idx) => 1 / (0.04 + (info?.indexWeights?.[idx] ?? 0.01)),
      });

      const relHues = hues.slice(1);
      shuffleInPlace(relHues, mulberry32(hashStringToU32(`${seedKey}:huePlan:${harmony}:hues`)));
      shuffleInPlace(picked, mulberry32(hashStringToU32(`${seedKey}:huePlan:${harmony}:idx`)));

      const hueByIndex = {};
      hueByIndex[baseIdx] = baseHue;
      const accentIndices = new Set();
      for (let i = 0; i < picked.length; i++) {
        hueByIndex[picked[i]] = relHues[i % relHues.length];
        accentIndices.add(picked[i]);
      }

      huePlan = {
        usedIndices,
        baseIdx,
        accentIndices,
        hueByIndex,
      };
    };

    const indexToColor =
      spec && typeof spec.h === "number" && typeof spec.s === "number" && typeof spec.b === "number"
        ? (idx, meta) => {
            const MAX_HUE_SHIFT_DEG = 18;
            const MAX_SAT_MUL = 1.2;
            const baseHue = clamp(spec.h, 0, 360);
            const baseS = clamp(spec.s, 0, 100) / 100;
            const baseB = clamp(spec.b, 0, 100) / 100;
            const mainGroup = hsvSpecToToneGroup(spec)?.groupId || null;
            const p = huePlan;
            const pickHue = typeof p?.hueByIndex?.[idx] === "number" ? p.hueByIndex[idx] : baseHue;
            const isBase = typeof p?.baseIdx === "number" && idx === p.baseIdx;
            const isAccent = !!p?.accentIndices?.has?.(idx);
            const tweaks = spec.tweaks && typeof spec.tweaks === "object" ? spec.tweaks : null;
            const tw = tweaks && tweaks[String(idx)] && typeof tweaks[String(idx)] === "object" ? tweaks[String(idx)] : null;
            const lumPos = typeof tw?.lumPos === "number" ? clamp(tw.lumPos, 0, 1) : baseB;
            const satMul = typeof tw?.satMul === "number" ? clamp(tw.satMul, 0, MAX_SAT_MUL) : 1;
            const hueShift = isAccent && typeof tw?.hueShift === "number" ? clamp(tw.hueShift, -MAX_HUE_SHIFT_DEG, MAX_HUE_SHIFT_DEG) : 0;
            const satScaleBase = isBase
              ? positionId === mainGroup
                ? 1
                : roleSatScale("dominant")
              : isAccent
                ? roleSatScale("accent")
                : roleSatScale("any");
            const satScale = clamp(satScaleBase * satMul, 0, 1);
            return toneIndexToHex({ idx, hue: wrapHue(pickHue + hueShift), sat01: baseS, b01: lumPos, satScale });
          }
        : null;

    const map = computeWeightedColorMap({
      svgText: uniqIds,
      colors,
      range,
      positionId,
      lengthId,
      templateMode,
      seedKey,
      indexToColor,
      onAssignment,
    });

    if (typeof onInfo === "function") {
      try {
        const usedIndices = Array.isArray(lastInfo?.usedIndices) ? lastInfo.usedIndices.slice() : [];
        onInfo({
          usedIndices,
          baseIdx: typeof huePlan?.baseIdx === "number" ? huePlan.baseIdx : null,
          accentIndices: huePlan?.accentIndices ? Array.from(huePlan.accentIndices) : [],
          hueByIndex: huePlan?.hueByIndex || {},
        });
      } catch {}
    }

    return applyColorMap(uniqIds, map);
  }

  let templateSvgCache = TEMPLATE_SVG_INLINE || null;
  let templateSvgRemoteAttempted = false;
  function loadTemplateSvgViaObject(url) {
    return new Promise((resolve) => {
      try {
        const obj = document.createElement("object");
        obj.type = "image/svg+xml";
        obj.data = url;
        obj.style.position = "fixed";
        obj.style.left = "-9999px";
        obj.style.top = "-9999px";
        obj.style.width = "1px";
        obj.style.height = "1px";
        obj.style.opacity = "0";
        obj.style.pointerEvents = "none";

        const cleanup = () => {
          try {
            obj.remove();
          } catch {}
        };

        obj.addEventListener(
          "load",
          () => {
            const svg = obj.contentDocument?.documentElement?.outerHTML || null;
            cleanup();
            resolve(typeof svg === "string" && svg.includes("<svg") ? svg : null);
          },
          { once: true }
        );
        obj.addEventListener(
          "error",
          () => {
            cleanup();
            resolve(null);
          },
          { once: true }
        );

        document.body.appendChild(obj);
      } catch {
        resolve(null);
      }
    });
  }

  async function loadTemplateSvg() {
    if (templateSvgRemoteAttempted) return templateSvgCache;
    templateSvgRemoteAttempted = true;

    // When opened via file://, browsers often block fetch/XHR for local assets.
    // We default to the inline fallback in that case.
    if (location.protocol === "file:") return templateSvgCache;

    const url = new URL(TEMPLATE_SVG_URL, location.href).toString();

    try {
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const txt = await res.text();
      if (txt && txt.trim()) templateSvgCache = txt;
      return templateSvgCache;
    } catch (e) {
      console.warn("[levels-tones] fetch() failed, trying <object> fallback:", e);
    }

    // Fallback for file:// or environments where fetch of local assets is blocked.
    const viaObject = await loadTemplateSvgViaObject(url);
    if (viaObject) {
      templateSvgCache = viaObject;
      return templateSvgCache;
    }

    console.warn("[levels-tones] <object> fallback also failed, using inline fallback if available.");
    return templateSvgCache;
  }

  function indexList([start, end]) {
    const out = [];
    for (let i = start; i <= end; i++) out.push(i);
    return out;
  }

  function pickFrom(rng, arr) {
    return arr[randInt(rng, 0, arr.length - 1)];
  }

  function uniq(arr) {
    return Array.from(new Set(arr));
  }

  function focusIndicesFor(range, group, desired) {
    const [start, end] = range;
    const [g0, g1] = group;

    const focus = [];
    for (let i = Math.max(start, g0); i <= Math.min(end, g1); i++) focus.push(i);
    if (focus.length === 0) {
      const mid = Math.round((start + end) / 2);
      focus.push(clamp(mid, start, end));
    }

    let guard = 0;
    while (focus.length < desired && guard++ < 40) {
      const min = Math.min(...focus);
      const max = Math.max(...focus);
      const canDown = min > start;
      const canUp = max < end;
      if (!canDown && !canUp) break;
      if (canDown && canUp) {
        // expand symmetrically when possible
        focus.push(min - 1, max + 1);
      } else if (canDown) focus.push(min - 1);
      else focus.push(max + 1);
    }
    return uniq(focus).sort((a, b) => a - b).slice(0, desired);
  }

  function ensureUniquePicks({ picks, want, pool, rng }) {
    const out = uniq(picks);
    let guard = 0;
    while (out.length < want && guard++ < 80) {
      out.push(pickFrom(rng, pool));
    }
    return uniq(out);
  }

  function sampleTone({ rng, focus, all, prefer, allowOutsideFocus }) {
    if (!allowOutsideFocus) return pickFrom(rng, focus);
    if (rng() < 0.68) return pickFrom(rng, focus);
    const outside = all.filter((x) => !focus.includes(x));
    if (outside.length === 0) return pickFrom(rng, focus);
    if (!prefer) return pickFrom(rng, outside);

    // Prefer picking farther from the focus for more visible differences.
    const focusCenter = (Math.min(...focus) + Math.max(...focus)) / 2;
    outside.sort((a, b) => Math.abs(b - focusCenter) - Math.abs(a - focusCenter));
    const top = outside.slice(0, Math.min(4, outside.length));
    return pickFrom(rng, top);
  }

  async function mount({ contentEl, panelEl, actionsEl, setPanelTitle }) {
    ensureStyles();
    setPanelTitle("色阶&影调");

    const state = loadState();
    const defaultTemplateSvg = (await loadTemplateSvg()) || TEMPLATE_SVG_INLINE;
    let activeTemplate = { mode: "default", svgText: defaultTemplateSvg, fileName: null, layerCount: null };
    let templateWarnText = "";

    contentEl.innerHTML = `<div class="lt-root"><div class="lt-scroll"><div class="lt" data-root></div></div></div>`;
    const root = contentEl.querySelector("[data-root]");

    panelEl.innerHTML = `
      <div class="lt-panel">
        <h2>色阶&影调</h2>
        <p class="sub">用 11 档灰阶理解「暗度/灰度/亮度」与「短调/中调/长调」，并在同一张书封面结构上观察 9 种影调差异。</p>

        <div class="card" style="margin-bottom:12px">
          <div class="row">
            <div class="left"><div class="name">显示标注</div></div>
            <label class="toggle"><input type="checkbox" data-showGuides /></label>
          </div>
          <div class="row" style="margin-top:10px">
            <div class="left"><div class="name">显示色阶标签</div></div>
            <label class="toggle"><input type="checkbox" data-showLabels /></label>
          </div>
        </div>

        <div class="card">
          <div class="row" style="margin-bottom:10px">
            <div class="left"><div class="name">纹理强度</div></div>
            <div class="mono muted" data-texVal>35%</div>
          </div>
          <input data-tex type="range" min="0" max="100" value="35" />
          <div class="sub" style="margin:10px 0 0">纹理只为强调“层次”，不参与色阶计算。</div>
        </div>

        <div class="card" style="margin-top:12px">
          <div class="row" style="margin-bottom:10px">
            <div class="left"><div class="name">影调 × 配色（HSB）</div></div>
            <div class="mono muted" data-colorTone>—</div>
          </div>

          <div class="lt-color">
            <div class="pair">
              <div class="lhs">
                <div class="name">当前影调</div>
                <div class="sub" style="margin:4px 0 0">主色与关系色默认全局生效；点击影调卡片可查看并微调该卡。</div>
              </div>
              <div class="rhs">
                <select data-colorPos aria-label="选择暗度/灰度/亮度"></select>
                <select data-colorLen aria-label="选择短调/中调/长调"></select>
              </div>
            </div>

            <div class="picker" style="margin-top:10px">
              <div class="sb" data-sb><div class="knob" data-knob></div></div>
              <input class="lt-hue" data-hue type="range" min="0" max="360" step="1" value="0" />
              <div class="meta">
                <div>H <span data-hVal>0</span>° · S <span data-sVal>85</span>% · B <span data-bVal>65</span>%</div>
                <div class="mono" data-hexVal>#—</div>
              </div>
            </div>

            <div class="pair" style="margin-top:2px">
              <div class="lhs">
                <div class="name">关系色</div>
                <div class="sub" style="margin:4px 0 0">用于小面积点缀；大面积优先保持同一影调结构。</div>
              </div>
              <div class="rhs">
                <select data-harmony aria-label="选择关系色"></select>
              </div>
            </div>

            <div class="swatches" data-colorSwatches style="margin-top:10px"></div>

            <div class="row" style="margin-top:10px">
              <button class="btn small" type="button" data-applyAll>一键应用到全部</button>
              <button class="btn small" type="button" data-clearThis>清除本卡配色</button>
              <button class="btn small" type="button" data-clearAll>清除全部配色</button>
            </div>
            <div class="sub" style="margin:10px 0 0">影调会锁定亮度：每一档亮度都有允许范围；若某档位不可达，会自动降低饱和度以保持影调不跑。</div>
          </div>
        </div>
      </div>
    `;

    const ui = {
      showGuides: panelEl.querySelector("[data-showGuides]"),
      showLabels: panelEl.querySelector("[data-showLabels]"),
      tex: panelEl.querySelector("[data-tex]"),
      texVal: panelEl.querySelector("[data-texVal]"),
      colorTone: panelEl.querySelector("[data-colorTone]"),
      colorPos: panelEl.querySelector("[data-colorPos]"),
      colorLen: panelEl.querySelector("[data-colorLen]"),
      sb: panelEl.querySelector("[data-sb]"),
      knob: panelEl.querySelector("[data-knob]"),
      hue: panelEl.querySelector("[data-hue]"),
      hVal: panelEl.querySelector("[data-hVal]"),
      sVal: panelEl.querySelector("[data-sVal]"),
      bVal: panelEl.querySelector("[data-bVal]"),
      hexVal: panelEl.querySelector("[data-hexVal]"),
      harmony: panelEl.querySelector("[data-harmony]"),
      colorSwatches: panelEl.querySelector("[data-colorSwatches]"),
      applyAll: panelEl.querySelector("[data-applyAll]"),
      clearThis: panelEl.querySelector("[data-clearThis]"),
      clearAll: panelEl.querySelector("[data-clearAll]"),
    };

    ui.showGuides.checked = !!state.showGuides;
    ui.showLabels.checked = !!state.showLabels;
    ui.tex.value = String(Math.round(state.texture * 100));
    ui.texVal.textContent = `${Math.round(state.texture * 100)}%`;

    const validKeys = new Set();
    for (const p of POSITIONS) for (const l of LENGTHS) validKeys.add(`${p.id}:${l.id}`);
    const ensureSelectedKey = () => {
      if (!validKeys.has(state.selectedKey)) state.selectedKey = "dark:short";
    };
    ensureSelectedKey();

    const fillSelect = (sel, items, getValue, getLabel) => {
      sel.replaceChildren();
      for (const it of items) {
        const opt = document.createElement("option");
        opt.value = getValue(it);
        opt.textContent = getLabel(it);
        sel.appendChild(opt);
      }
    };
    fillSelect(ui.colorPos, POSITIONS, (p) => p.id, (p) => p.label);
    fillSelect(ui.colorLen, LENGTHS, (l) => l.id, (l) => l.label);
    const HARMONY_TYPES = ["complement", "analogous", "adjacent", "triadic", "split", "warmcool", "off"];
    const MAX_HUE_SHIFT_DEG = 18;
    const MAX_SAT_MUL = 1.2;
    fillSelect(ui.harmony, HARMONY_TYPES, (x) => x, (x) => harmonyLabel(x));

    const parseSelected = () => {
      const [posId, lenId] = String(state.selectedKey || "dark:short").split(":");
      const pos = POSITIONS.find((p) => p.id === posId) || POSITIONS[0];
      const len = LENGTHS.find((l) => l.id === lenId) || LENGTHS[0];
      return { pos, len };
    };

    let cellEls = new Map();
    let cellRenderers = new Map();
    let cellInfoByKey = new Map();
    let activeTweakIdx = null;
    const updateSelectedCellsUi = () => {
      for (const [k, el] of cellEls.entries()) {
        if (!el) continue;
        el.classList.toggle("is-selected", k === state.selectedKey);
      }
    };
    const renderSelectedCell = () => {
      const fn = cellRenderers.get(state.selectedKey);
      if (typeof fn === "function") fn();
    };

    const setSelectedKey = (k) => {
      if (!validKeys.has(k)) return;
      state.selectedKey = k;
      activeTweakIdx = null;
      saveState(state);
      updateSelectedCellsUi();
      renderColorPanel();
    };

    const sanitizeColorSpec = (spec) => {
      if (!spec || typeof spec !== "object") return null;
      const h = clamp(Number(spec.h) || 0, 0, 360);
      const s = clamp(Number(spec.s) || 0, 0, 100);
      const b = clamp(Number(spec.b) || 0, 0, 100);
      const harmony = typeof spec.harmony === "string" ? spec.harmony : "complement";
      const out = { h, s, b, harmony: HARMONY_TYPES.includes(harmony) ? harmony : "complement" };

      const tweaksIn = spec.tweaks;
      if (tweaksIn && typeof tweaksIn === "object") {
        const tweaks = {};
        for (const [k, v] of Object.entries(tweaksIn)) {
          const idx = Number(k);
          if (!Number.isInteger(idx) || idx < 0 || idx > 10) continue;
          if (!v || typeof v !== "object") continue;
          const lumPos = typeof v.lumPos === "number" ? clamp(v.lumPos, 0, 1) : null;
          const satMul = typeof v.satMul === "number" ? clamp(v.satMul, 0, MAX_SAT_MUL) : null;
          const hueShift = typeof v.hueShift === "number" ? clamp(v.hueShift, -MAX_HUE_SHIFT_DEG, MAX_HUE_SHIFT_DEG) : null;

          const entry = {};
          if (typeof lumPos === "number") entry.lumPos = lumPos;
          if (typeof satMul === "number" && Math.abs(satMul - 1) > 0.0001) entry.satMul = satMul;
          if (typeof hueShift === "number" && Math.abs(hueShift) > 0.0001) entry.hueShift = hueShift;
          if (Object.keys(entry).length) tweaks[String(idx)] = entry;
        }
        if (Object.keys(tweaks).length) out.tweaks = tweaks;
      }
      return out;
    };

    const clonePlainObject = (obj) => {
      if (!obj || typeof obj !== "object") return obj;
      if (Array.isArray(obj)) return obj.map((x) => clonePlainObject(x));
      const out = {};
      for (const [k, v] of Object.entries(obj)) out[k] = clonePlainObject(v);
      return out;
    };

    const cloneColorSpec = (spec) => {
      const s = sanitizeColorSpec(spec);
      if (!s) return null;
      const out = { h: s.h, s: s.s, b: s.b, harmony: s.harmony };
      if (s.tweaks) out.tweaks = clonePlainObject(s.tweaks);
      return out;
    };

    const getColorSpecForKey = (k) => {
      const per = state.colorByCell && typeof state.colorByCell === "object" ? sanitizeColorSpec(state.colorByCell[k]) : null;
      return per || sanitizeColorSpec(state.colorDraft) || { h: 0, s: 85, b: 65, harmony: "complement" };
    };

    const ensureAllColorSpecs = () => {
      if (!state.colorByCell || typeof state.colorByCell !== "object") state.colorByCell = {};
      const draft = sanitizeColorSpec(state.colorDraft) || { h: 0, s: 85, b: 65, harmony: "complement" };
      const base = { h: draft.h, s: draft.s, b: draft.b, harmony: draft.harmony };
      state.colorDraft = base;
      for (const k of validKeys) {
        const cur = sanitizeColorSpec(state.colorByCell[k]);
        const next = { ...base };
        if (cur?.tweaks && typeof cur.tweaks === "object") next.tweaks = clonePlainObject(cur.tweaks);
        state.colorByCell[k] = sanitizeColorSpec(next) || next;
      }
    };
    ensureAllColorSpecs();

    let saveTimer = 0;
    const scheduleSave = () => {
      if (saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(() => {
        saveTimer = 0;
        saveState(state);
      }, 120);
    };

    let renderTimer = 0;
    const scheduleRenderSelectedCell = (immediate = false) => {
      if (immediate) {
        if (renderTimer) clearTimeout(renderTimer);
        renderTimer = 0;
        renderSelectedCell();
        return;
      }
      if (renderTimer) return;
      renderTimer = setTimeout(() => {
        renderTimer = 0;
        renderSelectedCell();
      }, 90);
    };

    const renderAllCells = () => {
      for (const fn of cellRenderers.values()) {
        if (typeof fn === "function") fn();
      }
    };

    let renderAllTimer = 0;
    const scheduleRenderAllCells = (immediate = false) => {
      if (immediate) {
        if (renderAllTimer) clearTimeout(renderAllTimer);
        renderAllTimer = 0;
        renderAllCells();
        return;
      }
      if (renderAllTimer) return;
      renderAllTimer = setTimeout(() => {
        renderAllTimer = 0;
        renderAllCells();
      }, 90);
    };

    const setPickerUi = (spec) => {
      const h = clamp(spec.h, 0, 360);
      const s = clamp(spec.s, 0, 100);
      const b = clamp(spec.b, 0, 100);
      const hueHex = rgb01ToHex(hsvToRgb01(h, 1, 1));
      ui.sb?.style?.setProperty("--hueColor", hueHex);

      if (ui.hue) ui.hue.value = String(Math.round(h));
      if (ui.hVal) ui.hVal.textContent = String(Math.round(h));
      if (ui.sVal) ui.sVal.textContent = String(Math.round(s));
      if (ui.bVal) ui.bVal.textContent = String(Math.round(b));
      if (ui.harmony) ui.harmony.value = spec.harmony;

      if (ui.knob && ui.sb) {
        ui.knob.style.left = `${clamp(s / 100, 0, 1) * 100}%`;
        ui.knob.style.top = `${(1 - clamp(b / 100, 0, 1)) * 100}%`;
      }

      const baseHex = rgb01ToHex(hsvToRgb01(h, s / 100, b / 100));
      if (ui.hexVal) ui.hexVal.textContent = baseHex;
    };

    const computeHexForIndex = ({ idx, spec, info }) => {
      const baseHue = clamp(spec.h, 0, 360);
      const baseS = clamp(spec.s, 0, 100) / 100;
      const baseB = clamp(spec.b, 0, 100) / 100;
      const mainGroup = hsvSpecToToneGroup(spec)?.groupId || null;
      const cardGroup = typeof info?.positionId === "string" ? info.positionId : String(state.selectedKey || "dark:short").split(":")[0];
      const hueByIndex = info?.hueByIndex && typeof info.hueByIndex === "object" ? info.hueByIndex : {};
      const idealHue = typeof hueByIndex[idx] === "number" ? hueByIndex[idx] : baseHue;
      const baseIdx = typeof info?.baseIdx === "number" ? info.baseIdx : null;
      const accents = new Set(Array.isArray(info?.accentIndices) ? info.accentIndices : []);
      const isBase = typeof baseIdx === "number" && idx === baseIdx;
      const isAccent = accents.has(idx);

      const tweaks = spec.tweaks && typeof spec.tweaks === "object" ? spec.tweaks : null;
      const tw = tweaks && tweaks[String(idx)] && typeof tweaks[String(idx)] === "object" ? tweaks[String(idx)] : null;
      const lumPos = typeof tw?.lumPos === "number" ? clamp(tw.lumPos, 0, 1) : baseB;
      const satMul = typeof tw?.satMul === "number" ? clamp(tw.satMul, 0, MAX_SAT_MUL) : 1;
      const hueShift = isAccent && typeof tw?.hueShift === "number" ? clamp(tw.hueShift, -MAX_HUE_SHIFT_DEG, MAX_HUE_SHIFT_DEG) : 0;
      const satScaleBase = isBase
        ? cardGroup === mainGroup
          ? 1
          : roleSatScale("dominant")
        : isAccent
          ? roleSatScale("accent")
          : roleSatScale("any");
      const satScale = clamp(satScaleBase * satMul, 0, 1);

      return toneIndexToHex({ idx, hue: wrapHue(idealHue + hueShift), sat01: baseS, b01: lumPos, satScale });
    };

    const fmtSigned = (n, unit) => {
      const v = Math.round(Number(n) || 0);
      if (!v) return `0${unit}`;
      return `${v > 0 ? "+" : ""}${v}${unit}`;
    };

    const tweakUi = (() => {
      const root = document.createElement("div");
      root.className = "lt-pop";
      root.style.display = "none";
      root.innerHTML = `
        <div class="lt-popCard" data-card role="dialog" aria-label="色阶微调">
          <div class="lt-popHead">
            <div class="lt-popPill">
              <div class="lt-popDot" data-dot></div>
              <div class="lt-popTxt">
                <div class="lt-popTitle" data-title>—</div>
                <div class="lt-popHex" data-hex>#—</div>
              </div>
            </div>
            <div class="lt-popActions">
              <button class="btn small" type="button" data-reset>重置</button>
              <button class="btn small" type="button" data-close>关闭</button>
            </div>
          </div>

          <div class="lt-popPad" data-pad style="--hueColor:#ff0000;--ya:0;--yb:1;--x:.83;--y:.5">
            <div class="lt-popBand" data-band></div>
            <div class="lt-popKnob" data-knob></div>
          </div>

          <div class="lt-popMeta">
            <div data-range>允许范围 —</div>
            <div class="mono" data-lum>—</div>
          </div>
          <div class="lt-popMeta">
            <div class="delta" data-dLum>Δ亮度 0%</div>
            <div class="delta" data-dSat>Δ饱和 0%</div>
            <div class="delta" data-dHue style="display:none">ΔHue 0°</div>
          </div>

          <div class="lt-popRows">
            <div class="lt-popRow" data-hueRow style="display:none">
              <div class="lab">色相微调</div>
              <input type="range" min="-${MAX_HUE_SHIFT_DEG}" max="${MAX_HUE_SHIFT_DEG}" step="1" value="0" data-hueShift />
              <div class="val" data-hueShiftVal>0°</div>
            </div>
          </div>
        </div>
      `;
      document.body.appendChild(root);
      const q = (sel) => root.querySelector(sel);
      return {
        root,
        dot: q("[data-dot]"),
        title: q("[data-title]"),
        hex: q("[data-hex]"),
        pad: q("[data-pad]"),
        range: q("[data-range]"),
        lum: q("[data-lum]"),
        dLum: q("[data-dLum]"),
        dSat: q("[data-dSat]"),
        dHue: q("[data-dHue]"),
        hueRow: q("[data-hueRow]"),
        hueShift: q("[data-hueShift]"),
        hueShiftVal: q("[data-hueShiftVal]"),
        closeBtn: q("[data-close]"),
        resetBtn: q("[data-reset]"),
        band: [0, 1],
      };
    })();

    const positionTweakPopover = (anchorEl) => {
      if (!tweakUi?.root || !anchorEl) return;
      const gap = 8;
      const a = anchorEl.getBoundingClientRect();
      const pop = tweakUi.root;
      pop.style.display = "block";
      pop.style.left = "0px";
      pop.style.top = "0px";
      const r = pop.getBoundingClientRect();
      let left = a.left;
      let top = a.bottom + gap;
      const maxL = Math.max(gap, window.innerWidth - gap - r.width);
      const maxT = Math.max(gap, window.innerHeight - gap - r.height);
      if (left > maxL) left = maxL;
      if (left < gap) left = gap;
      if (top > maxT) top = a.top - gap - r.height;
      if (top < gap) top = gap;
      pop.style.left = `${Math.round(left)}px`;
      pop.style.top = `${Math.round(top)}px`;
    };

    const updateSwatchRowForIdx = (idx, spec, info) => {
      if (!ui.colorSwatches) return;
      if (typeof idx !== "number") return;
      const row = ui.colorSwatches.querySelector(`[data-sw-idx="${idx}"]`);
      if (!row) return;
      const dot = row.querySelector(".dot");
      const val = row.querySelector(".val");
      const hex = computeHexForIndex({ idx, spec, info });
      if (dot) dot.style.background = hex;
      if (val) val.textContent = `${idx} ${hex}`;
    };

    const syncTweakPopover = (spec) => {
      if (!tweakUi?.root) return;
      const k = String(state.selectedKey || "dark:short");
      const info = cellInfoByKey.get(k);
      const used = Array.isArray(info?.usedIndices) ? info.usedIndices : null;
      const idx = activeTweakIdx;
      if (!used || !used.length || typeof idx !== "number" || !used.includes(idx)) {
        tweakUi.root.style.display = "none";
        return;
      }
      const anchor = ui.colorSwatches?.querySelector?.(`[data-sw-idx="${idx}"]`);
      if (!anchor) {
        tweakUi.root.style.display = "none";
        return;
      }

      const accents = new Set(Array.isArray(info?.accentIndices) ? info.accentIndices : []);
      const baseIdx = typeof info?.baseIdx === "number" ? info.baseIdx : null;
      const isAccent = accents.has(idx);
      const tag = typeof baseIdx === "number" && idx === baseIdx ? "主" : isAccent ? "关系" : "主";

      const baseHue = clamp(spec.h, 0, 360);
      const hueByIndex = info?.hueByIndex && typeof info.hueByIndex === "object" ? info.hueByIndex : {};
      const idealHue = typeof hueByIndex[idx] === "number" ? hueByIndex[idx] : baseHue;

      const tweaks = spec.tweaks && typeof spec.tweaks === "object" ? spec.tweaks : null;
      const tw = tweaks && tweaks[String(idx)] && typeof tweaks[String(idx)] === "object" ? tweaks[String(idx)] : {};
      const baseLumPos = clamp(spec.b, 0, 100) / 100;
      const lumPos = typeof tw?.lumPos === "number" ? clamp(tw.lumPos, 0, 1) : baseLumPos;
      const satMul = typeof tw?.satMul === "number" ? clamp(tw.satMul, 0, MAX_SAT_MUL) : 1;
      const hueShift = isAccent && typeof tw?.hueShift === "number" ? clamp(tw.hueShift, -MAX_HUE_SHIFT_DEG, MAX_HUE_SHIFT_DEG) : 0;

      const hex = computeHexForIndex({ idx, spec, info });
      const L = relLuminanceFromHex(hex);
      const band = getLevelLuminanceBands()[clamp(idx, 0, 10)];
      const [Lmin, Lmax] = band;
      tweakUi.band = band;

      tweakUi.root.style.display = "block";
      tweakUi.dot.style.background = hex;
      tweakUi.title.textContent = `${tag} 色阶 ${idx}`;
      tweakUi.hex.textContent = hex;

      tweakUi.range.textContent = `允许范围 L ${Lmin.toFixed(3)}–${Lmax.toFixed(3)}`;
      tweakUi.lum.textContent = `当前 L ${L.toFixed(3)}`;
      tweakUi.dLum.textContent = `Δ亮度 ${fmtSigned((lumPos - baseLumPos) * 100, "%")}`;
      tweakUi.dSat.textContent = `Δ饱和 ${fmtSigned((satMul - 1) * 100, "%")}`;
      if (tweakUi.dHue) {
        tweakUi.dHue.style.display = isAccent ? "" : "none";
        tweakUi.dHue.textContent = `ΔHue ${fmtSigned(hueShift, "°")}`;
      }

      // Pad: y=luminance (restricted to this tone band), x=saturation multiplier.
      const actualHue = wrapHue(idealHue + hueShift);
      const hueColor = rgb01ToHex(hsvToRgb01(actualHue, 1, 1));
      if (tweakUi.pad) {
        tweakUi.pad.style.setProperty("--hueColor", hueColor);
        tweakUi.pad.style.setProperty("--ya", String(clamp(1 - Lmax, 0, 1)));
        tweakUi.pad.style.setProperty("--yb", String(clamp(1 - Lmin, 0, 1)));

        const x01 = clamp(satMul / MAX_SAT_MUL, 0, 1);
        const targetLum = Lmin + (Lmax - Lmin) * clamp(lumPos, 0, 1);
        const y01 = clamp(1 - targetLum, 0, 1);
        tweakUi.pad.style.setProperty("--x", String(x01));
        tweakUi.pad.style.setProperty("--y", String(y01));
      }

      if (tweakUi.hueRow) tweakUi.hueRow.style.display = isAccent ? "" : "none";
      if (tweakUi.hueShift) {
        tweakUi.hueShift.value = String(Math.round(hueShift));
        const p = ((hueShift + MAX_HUE_SHIFT_DEG) / (MAX_HUE_SHIFT_DEG * 2)) * 100;
        tweakUi.hueShift.style.setProperty("--p", `${clamp(p, 0, 100)}%`);
      }
      if (tweakUi.hueShiftVal) tweakUi.hueShiftVal.textContent = `${fmtSigned(hueShift, "°")} · H ${Math.round(actualHue)}°`;

      positionTweakPopover(anchor);
    };

    const renderColorSwatches = (spec) => {
      if (!ui.colorSwatches) return;
      ui.colorSwatches.replaceChildren();

      const baseHue = clamp(spec.h, 0, 360);
      const baseS = clamp(spec.s, 0, 100) / 100;
      const baseB = clamp(spec.b, 0, 100) / 100;

      const addSw = (name, idx, hex) => {
        const row = document.createElement("div");
        row.className = "sw";
        if (typeof idx === "number") row.dataset.swIdx = String(idx);
        const dot = document.createElement("div");
        dot.className = "dot";
        dot.style.background = hex;
        const n = document.createElement("div");
        n.className = "name";
        n.textContent = name;
        const v = document.createElement("div");
        v.className = "val";
        v.textContent = typeof idx === "number" ? `${idx} ${hex}` : String(hex);
        row.appendChild(dot);
        row.appendChild(n);
        row.appendChild(v);
        ui.colorSwatches.appendChild(row);
        return row;
      };

      const k = String(state.selectedKey || "dark:short");
      const info = cellInfoByKey.get(k);
      const used = Array.isArray(info?.usedIndices) ? info.usedIndices.slice() : null;
      if (used && used.length) {
        used.sort((a, b) => a - b);
        const baseIdx = typeof info?.baseIdx === "number" ? info.baseIdx : null;
        const accents = new Set(Array.isArray(info?.accentIndices) ? info.accentIndices : []);
        for (const idx of used) {
          const tag = idx === baseIdx ? "主" : accents.has(idx) ? "关系" : "主";
          const hex = computeHexForIndex({ idx, spec, info });
          const row = addSw(`${tag} 色阶`, idx, hex);
          if (row) {
            row.classList.toggle("is-active", typeof activeTweakIdx === "number" && idx === activeTweakIdx);
            row.addEventListener("click", (e) => {
              e.preventDefault();
              activeTweakIdx = typeof activeTweakIdx === "number" && activeTweakIdx === idx ? null : idx;
              renderColorPanel();
            });
          }
        }
        return;
      }

      // Fallback: show the tone-locked palette for indices 0–10 using the base hue.
      for (let i = 0; i <= 10; i++) {
        const hex = toneIndexToHex({ idx: i, hue: baseHue, sat01: baseS, b01: baseB, satScale: roleSatScale("any") });
        const row = addSw(`色阶 ${i}`, i, hex);
        if (row) row.style.cursor = "default";
      }
    };

    const renderColorPanel = () => {
      ensureSelectedKey();
      const { pos, len } = parseSelected();
      ui.colorPos.value = pos.id;
      ui.colorLen.value = len.id;

      const k = `${pos.id}:${len.id}`;
      const spec = getColorSpecForKey(k);
      if (ui.colorTone) ui.colorTone.textContent = `${toneTitle(pos.label, len.label)} · ${harmonyLabel(spec.harmony)}`;
      setPickerUi(spec);
      renderColorSwatches(spec);
      syncTweakPopover(spec);
    };

    const applySpecToSelected = (spec, opts) => {
      ensureSelectedKey();
      const k = String(state.selectedKey || "dark:short");
      if (!state.colorByCell || typeof state.colorByCell !== "object") state.colorByCell = {};
      const cloned = cloneColorSpec(spec);
      if (!cloned) return;
      state.colorDraft = { h: cloned.h, s: cloned.s, b: cloned.b, harmony: cloned.harmony };
      state.colorByCell[k] = cloneColorSpec(cloned) || cloned;
      scheduleSave();
      scheduleRenderSelectedCell(!!opts?.immediateRender);
      if (opts?.skipPanel) {
        try {
          const nextSpec = getColorSpecForKey(k);
          const info = cellInfoByKey.get(k);
          if (typeof activeTweakIdx === "number") updateSwatchRowForIdx(activeTweakIdx, nextSpec, info);
          syncTweakPopover(nextSpec);
        } catch {}
      } else {
        renderColorPanel();
      }
    };

    const applyBaseToAll = (specPatch, opts) => {
      const cur = sanitizeColorSpec(state.colorDraft) || { h: 0, s: 85, b: 65, harmony: "complement" };
      const nextFull = sanitizeColorSpec({ ...cur, ...(specPatch && typeof specPatch === "object" ? specPatch : {}) });
      if (!nextFull) return;
      const base = { h: nextFull.h, s: nextFull.s, b: nextFull.b, harmony: nextFull.harmony };
      state.colorDraft = base;
      if (!state.colorByCell || typeof state.colorByCell !== "object") state.colorByCell = {};
      for (const k of validKeys) {
        const curSpec = sanitizeColorSpec(state.colorByCell[k]);
        const nextSpec = { ...base };
        if (curSpec?.tweaks && typeof curSpec.tweaks === "object") nextSpec.tweaks = clonePlainObject(curSpec.tweaks);
        state.colorByCell[k] = sanitizeColorSpec(nextSpec) || nextSpec;
      }
      scheduleSave();
      // Keep the focused card responsive; other cards can follow shortly.
      scheduleRenderSelectedCell(true);
      scheduleRenderAllCells(!!opts?.immediateRender);
      renderColorPanel();
    };

    const updateIndexTweak = (idx, patch, opts) => {
      const i = Number(idx);
      if (!Number.isInteger(i) || i < 0 || i > 10) return;
      const cur = getColorSpecForKey(state.selectedKey);
      const next = { ...cur };
      const tweaks = cur.tweaks && typeof cur.tweaks === "object" ? { ...cur.tweaks } : {};
      const key = String(i);
      const prev = tweaks[key] && typeof tweaks[key] === "object" ? { ...tweaks[key] } : {};
      const merged = { ...prev, ...(patch && typeof patch === "object" ? patch : {}) };

      if (typeof merged.lumPos === "number") merged.lumPos = clamp(merged.lumPos, 0, 1);
      else delete merged.lumPos;

      if (typeof merged.satMul === "number") merged.satMul = clamp(merged.satMul, 0, MAX_SAT_MUL);
      else delete merged.satMul;
      if (typeof merged.satMul === "number" && Math.abs(merged.satMul - 1) < 0.0001) delete merged.satMul;

      if (typeof merged.hueShift === "number") merged.hueShift = clamp(merged.hueShift, -MAX_HUE_SHIFT_DEG, MAX_HUE_SHIFT_DEG);
      else delete merged.hueShift;
      if (typeof merged.hueShift === "number" && Math.abs(merged.hueShift) < 0.0001) delete merged.hueShift;

      if (Object.keys(merged).length) tweaks[key] = merged;
      else delete tweaks[key];

      if (Object.keys(tweaks).length) next.tweaks = tweaks;
      else delete next.tweaks;

      const sanitized = sanitizeColorSpec(next);
      if (!sanitized) return;
      applySpecToSelected(sanitized, opts);
    };

    const clearIndexTweak = (idx, opts) => {
      const i = Number(idx);
      if (!Number.isInteger(i) || i < 0 || i > 10) return;
      const cur = getColorSpecForKey(state.selectedKey);
      if (!cur.tweaks || typeof cur.tweaks !== "object") return;
      const tweaks = { ...cur.tweaks };
      delete tweaks[String(i)];
      const next = { ...cur };
      if (Object.keys(tweaks).length) next.tweaks = tweaks;
      else delete next.tweaks;
      const sanitized = sanitizeColorSpec(next);
      if (!sanitized) return;
      applySpecToSelected(sanitized, opts);
    };

    const closeTweakPopover = () => {
      activeTweakIdx = null;
      renderColorPanel();
    };

    const onTweakClose = (e) => {
      e.preventDefault();
      closeTweakPopover();
    };

    const onTweakReset = (e) => {
      e.preventDefault();
      if (typeof activeTweakIdx !== "number") return;
      clearIndexTweak(activeTweakIdx, { immediateRender: true });
    };

    const setPadFromClient = (clientX, clientY, { commit }) => {
      if (typeof activeTweakIdx !== "number") return;
      if (!tweakUi?.pad) return;
      const rect = tweakUi.pad.getBoundingClientRect();
      const x01 = rect.width ? clamp((clientX - rect.left) / rect.width, 0, 1) : 0;
      const y01 = rect.height ? clamp((clientY - rect.top) / rect.height, 0, 1) : 0;
      const [Lmin, Lmax] = Array.isArray(tweakUi.band) ? tweakUi.band : [0, 1];
      const lum = clamp(1 - y01, Lmin, Lmax);
      const lumPos = Lmax > Lmin ? (lum - Lmin) / (Lmax - Lmin) : 0.5;
      const satMul = clamp(x01 * MAX_SAT_MUL, 0, MAX_SAT_MUL);
      updateIndexTweak(activeTweakIdx, { lumPos, satMul }, { immediateRender: !!commit, skipPanel: true });
    };

    let padPointerId = null;
    const onPadPointerDown = (e) => {
      if (!(e instanceof PointerEvent)) return;
      if (!tweakUi?.pad) return;
      e.preventDefault();
      padPointerId = e.pointerId;
      tweakUi.pad.setPointerCapture?.(e.pointerId);
      setPadFromClient(e.clientX, e.clientY, { commit: false });
    };
    const onPadPointerMove = (e) => {
      if (!(e instanceof PointerEvent)) return;
      if (!tweakUi?.pad) return;
      if (padPointerId !== e.pointerId) return;
      if (!tweakUi.pad.hasPointerCapture?.(e.pointerId)) return;
      setPadFromClient(e.clientX, e.clientY, { commit: false });
    };
    const onPadPointerUp = (e) => {
      if (!(e instanceof PointerEvent)) return;
      if (!tweakUi?.pad) return;
      if (padPointerId !== e.pointerId) return;
      padPointerId = null;
      try {
        tweakUi.pad.releasePointerCapture?.(e.pointerId);
      } catch {}
      setPadFromClient(e.clientX, e.clientY, { commit: true });
    };

    const onHueShiftInput = () => {
      if (typeof activeTweakIdx !== "number") return;
      const v = clamp(Number(tweakUi?.hueShift?.value) || 0, -MAX_HUE_SHIFT_DEG, MAX_HUE_SHIFT_DEG);
      updateIndexTweak(activeTweakIdx, { hueShift: v }, { immediateRender: false, skipPanel: true });
    };
    const onHueShiftChange = () => {
      if (typeof activeTweakIdx !== "number") return;
      const v = clamp(Number(tweakUi?.hueShift?.value) || 0, -MAX_HUE_SHIFT_DEG, MAX_HUE_SHIFT_DEG);
      updateIndexTweak(activeTweakIdx, { hueShift: v }, { immediateRender: true, skipPanel: true });
    };

    const onDocPointerDown = (e) => {
      if (typeof activeTweakIdx !== "number") return;
      const t = e?.target;
      if (tweakUi?.root && t && tweakUi.root.contains(t)) return;
      if (t instanceof Element && t.closest?.("[data-sw-idx]")) return;
      closeTweakPopover();
    };
    const onDocKeyDown = (e) => {
      if (!(e instanceof KeyboardEvent)) return;
      if (e.key !== "Escape") return;
      if (typeof activeTweakIdx !== "number") return;
      e.preventDefault();
      closeTweakPopover();
    };

    if (tweakUi?.closeBtn) tweakUi.closeBtn.addEventListener("click", onTweakClose);
    if (tweakUi?.resetBtn) tweakUi.resetBtn.addEventListener("click", onTweakReset);
    if (tweakUi?.pad) {
      tweakUi.pad.addEventListener("pointerdown", onPadPointerDown);
      tweakUi.pad.addEventListener("pointermove", onPadPointerMove);
      tweakUi.pad.addEventListener("pointerup", onPadPointerUp);
      tweakUi.pad.addEventListener("pointercancel", onPadPointerUp);
    }
    if (tweakUi?.hueShift) {
      tweakUi.hueShift.addEventListener("input", onHueShiftInput);
      tweakUi.hueShift.addEventListener("change", onHueShiftChange);
    }
    document.addEventListener("pointerdown", onDocPointerDown, true);
    window.addEventListener("keydown", onDocKeyDown);

    const onSelectChange = () => {
      const k = `${ui.colorPos.value}:${ui.colorLen.value}`;
      setSelectedKey(k);
    };
    ui.colorPos.addEventListener("change", onSelectChange);
    ui.colorLen.addEventListener("change", onSelectChange);

    const onHueInput = () => {
      applyBaseToAll({ h: Number(ui.hue.value) || 0 }, { immediateRender: false });
    };
    ui.hue.addEventListener("input", onHueInput);

    const onHarmonyChange = () => {
      applyBaseToAll({ harmony: String(ui.harmony.value || "complement") }, { immediateRender: true });
    };
    ui.harmony.addEventListener("change", onHarmonyChange);

    const setSbFromClient = (clientX, clientY) => {
      if (!ui.sb) return;
      const rect = ui.sb.getBoundingClientRect();
      const x01 = rect.width ? clamp((clientX - rect.left) / rect.width, 0, 1) : 0;
      const y01 = rect.height ? clamp((clientY - rect.top) / rect.height, 0, 1) : 0;
      const s = Math.round(x01 * 100);
      const b = Math.round((1 - y01) * 100);
      applyBaseToAll({ s, b }, { immediateRender: false });
    };

    const onSbPointerDown = (e) => {
      if (!(e instanceof PointerEvent)) return;
      e.preventDefault();
      ui.sb.setPointerCapture?.(e.pointerId);
      setSbFromClient(e.clientX, e.clientY);
    };
    const onSbPointerMove = (e) => {
      if (!(e instanceof PointerEvent)) return;
      if (!ui.sb.hasPointerCapture?.(e.pointerId)) return;
      setSbFromClient(e.clientX, e.clientY);
    };
    const onSbPointerUp = (e) => {
      if (!(e instanceof PointerEvent)) return;
      try {
        ui.sb.releasePointerCapture?.(e.pointerId);
      } catch {}
      scheduleRenderAllCells(true);
      scheduleRenderSelectedCell(true);
    };
    ui.sb.addEventListener("pointerdown", onSbPointerDown);
    ui.sb.addEventListener("pointermove", onSbPointerMove);
    ui.sb.addEventListener("pointerup", onSbPointerUp);
    ui.sb.addEventListener("pointercancel", onSbPointerUp);

    const onApplyAll = (e) => {
      e.preventDefault();
      ensureSelectedKey();
      const selKey = String(state.selectedKey || "dark:short");
      const selSpec = cloneColorSpec(getColorSpecForKey(selKey));
      if (!selSpec) return;

      // Sync tweaks "by slot":
      // - dominant slot follows each card's baseIdx
      // - accent slots follow each card's hue-by-index mapping (same harmony hues, different tone indices)
      const hueKey = (h) => String(Math.round(wrapHue(h)));
      const slot = { dominant: null, accents: new Map() };
      const selInfo = cellInfoByKey.get(selKey);
      if (selInfo && typeof selInfo === "object" && selSpec.tweaks && typeof selSpec.tweaks === "object") {
        const baseIdx = typeof selInfo.baseIdx === "number" ? selInfo.baseIdx : null;
        if (typeof baseIdx === "number") {
          const tw = selSpec.tweaks[String(baseIdx)];
          if (tw && typeof tw === "object") slot.dominant = clonePlainObject(tw);
        }
        const hueByIndex = selInfo.hueByIndex && typeof selInfo.hueByIndex === "object" ? selInfo.hueByIndex : {};
        const accents = Array.isArray(selInfo.accentIndices) ? selInfo.accentIndices : [];
        for (const idx of accents) {
          const tw = selSpec.tweaks[String(idx)];
          if (!tw || typeof tw !== "object") continue;
          const h = hueByIndex?.[idx];
          if (typeof h !== "number") continue;
          slot.accents.set(hueKey(h), clonePlainObject(tw));
        }
      }

      const baseSpec = { h: selSpec.h, s: selSpec.s, b: selSpec.b, harmony: selSpec.harmony };

      // Pass 1: apply base HSB + harmony to all, clear per-card tweaks (keeps behavior predictable).
      if (!state.colorByCell || typeof state.colorByCell !== "object") state.colorByCell = {};
      for (const k of validKeys) state.colorByCell[k] = { ...baseSpec };
      state.colorDraft = { ...baseSpec };
      saveState(state);
      renderAll();

      // Pass 2: remap slot tweaks onto each card's indices (requires the post-apply hue plan info).
      if (slot.dominant || slot.accents.size) {
        for (const k of validKeys) {
          const info = cellInfoByKey.get(k);
          if (!info || typeof info !== "object") continue;
          const tweaks = {};

          const baseIdx = typeof info.baseIdx === "number" ? info.baseIdx : null;
          if (slot.dominant && typeof baseIdx === "number") tweaks[String(baseIdx)] = clonePlainObject(slot.dominant);

          const hueByIndex = info.hueByIndex && typeof info.hueByIndex === "object" ? info.hueByIndex : {};
          for (const [hk, tw] of slot.accents.entries()) {
            let foundIdx = null;
            for (const [idxStr, h] of Object.entries(hueByIndex)) {
              if (typeof h !== "number") continue;
              if (hueKey(h) !== hk) continue;
              const idxNum = Number(idxStr);
              if (!Number.isInteger(idxNum) || idxNum < 0 || idxNum > 10) continue;
              foundIdx = idxNum;
              break;
            }
            if (typeof foundIdx === "number") tweaks[String(foundIdx)] = clonePlainObject(tw);
          }

          const spec = { ...baseSpec };
          if (Object.keys(tweaks).length) spec.tweaks = tweaks;
          state.colorByCell[k] = sanitizeColorSpec(spec) || spec;
        }
        saveState(state);
        renderAll();
      }
    };
    ui.applyAll.addEventListener("click", onApplyAll);

    const onClearThis = (e) => {
      e.preventDefault();
      const k = String(state.selectedKey || "dark:short");
      const base = sanitizeColorSpec(state.colorDraft) || { h: 0, s: 85, b: 65, harmony: "complement" };
      if (!state.colorByCell || typeof state.colorByCell !== "object") state.colorByCell = {};
      state.colorByCell[k] = { h: base.h, s: base.s, b: base.b, harmony: base.harmony };
      activeTweakIdx = null;
      saveState(state);
      renderSelectedCell();
      renderColorPanel();
    };
    ui.clearThis.addEventListener("click", onClearThis);

    const onClearAll = (e) => {
      e.preventDefault();
      const base = sanitizeColorSpec(state.colorDraft) || { h: 0, s: 85, b: 65, harmony: "complement" };
      if (!state.colorByCell || typeof state.colorByCell !== "object") state.colorByCell = {};
      for (const k of validKeys) state.colorByCell[k] = { h: base.h, s: base.s, b: base.b, harmony: base.harmony };
      activeTweakIdx = null;
      saveState(state);
      renderAllCells();
      renderColorPanel();
    };
    ui.clearAll.addEventListener("click", onClearAll);

    const templateUi = { uploadBtn: null, restoreBtn: null, status: null, warn: null };
    const setTemplateUiEls = (els) => {
      templateUi.uploadBtn = els?.uploadBtn || null;
      templateUi.restoreBtn = els?.restoreBtn || null;
      templateUi.status = els?.status || null;
      templateUi.warn = els?.warn || null;
      setTemplateUi();
    };

    const describeLayerCount = (n) => `识别到 ${n} 个可变色层`;

    const setTemplateUi = () => {
      const statusEl = templateUi.status;
      if (statusEl) {
        if (activeTemplate.mode === "default") statusEl.textContent = "当前：默认模板";
        else {
          const name = activeTemplate.fileName ? `已应用：${activeTemplate.fileName}` : "已应用：自定义模板";
          const layers = typeof activeTemplate.layerCount === "number" ? ` · 可变色层 ${activeTemplate.layerCount}` : "";
          statusEl.textContent = `${name}${layers}`;
        }
      }

      const restoreBtn = templateUi.restoreBtn;
      if (restoreBtn) restoreBtn.style.display = activeTemplate.mode === "custom" ? "" : "none";

      const warnEl = templateUi.warn;
      if (warnEl) {
        if (templateWarnText) {
          warnEl.textContent = templateWarnText;
          warnEl.style.display = "";
        } else {
          warnEl.textContent = "";
          warnEl.style.display = "none";
        }
      }
    };

    const isSvgFile = (file) => {
      if (!file) return false;
      const name = String(file.name || "");
      const type = String(file.type || "");
      return /\.svg$/i.test(name) || type === "image/svg+xml";
    };

    const uploadInput = document.createElement("input");
    uploadInput.type = "file";
    uploadInput.accept = ".svg,image/svg+xml";
    uploadInput.style.display = "none";
    panelEl.appendChild(uploadInput);

    const sanitizeSvgForInline = (raw) => {
      try {
        const doc = new DOMParser().parseFromString(String(raw || ""), "image/svg+xml");
        if (doc.querySelector("parsererror")) return null;
        const root = doc.documentElement;
        if (!root || String(root.tagName || "").toLowerCase() !== "svg") return null;

        // Remove scripts and inline event handlers to avoid executing arbitrary code from an uploaded SVG.
        for (const s of Array.from(root.querySelectorAll("script"))) s.remove();
        for (const el of Array.from(root.querySelectorAll("*"))) {
          for (const attr of Array.from(el.attributes || [])) {
            const name = String(attr.name || "");
            const value = String(attr.value || "");
            if (/^on/i.test(name)) el.removeAttribute(name);
            if ((name === "href" || name === "xlink:href") && /^\s*javascript:/i.test(value)) el.removeAttribute(name);
          }
        }
        return root.outerHTML || null;
      } catch {
        return null;
      }
    };

    const countRecolorLayers = (svgText) => {
      const w = estimateColorWeights(svgText) || {};
      return Object.keys(w).filter((k) => typeof w[k] === "number" && w[k] > 0).length;
    };

    const restoreDefaultTemplate = () => {
      activeTemplate = { mode: "default", svgText: defaultTemplateSvg, fileName: null, layerCount: null };
      templateWarnText = "";
      setTemplateUi();
      renderAll();
    };

    const applyUploadedTemplate = async (file) => {
      templateWarnText = "";
      setTemplateUi();

      if (!file) return;
      if (!isSvgFile(file)) {
        templateWarnText = "仅支持 SVG 文件。";
        setTemplateUi();
        return;
      }

      let raw = "";
      try {
        raw = await file.text();
      } catch (e) {
        templateWarnText = `读取失败：${String(e?.message || e)}`;
        setTemplateUi();
        return;
      }

      const sanitized = sanitizeSvgForInline(raw);
      if (!sanitized) {
        templateWarnText = "解析失败：请确认文件是有效的 SVG。";
        setTemplateUi();
        return;
      }

      const layers = countRecolorLayers(sanitized);
      if (layers <= 0) {
        templateWarnText = "未识别到可变色图层：请确保 SVG 使用 #RRGGBB（或 white/black）作为 fill/stroke。";
        setTemplateUi();
        return;
      }
      if (layers < 4) {
        templateWarnText = `无法使用：${describeLayerCount(layers)}，层数过少（至少 4 层）。`;
        setTemplateUi();
        return;
      }

      activeTemplate = { mode: "custom", svgText: sanitized, fileName: String(file.name || "自定义.svg"), layerCount: layers };
      templateWarnText = "";
      setTemplateUi();
      renderAll();
    };

    const onUploadClick = () => {
      try {
        uploadInput?.click();
      } catch {}
    };
    const onUploadChange = async () => {
      const file = uploadInput?.files?.[0] || null;
      if (uploadInput) uploadInput.value = "";
      await applyUploadedTemplate(file);
    };
    const onRestoreTemplate = () => restoreDefaultTemplate();

    uploadInput?.addEventListener("change", onUploadChange);

    function renderLevelsSection() {
      const card = document.createElement("div");
      card.className = "card";

      const head = document.createElement("div");
      head.className = "row";
      head.style.marginBottom = "10px";
      head.innerHTML = `
        <div class="left"><div class="name">11 个色阶（纯黑 → 纯白）</div></div>
        <div class="mono muted">0–10</div>
      `;
      card.appendChild(head);

      const grid = document.createElement("div");
      grid.className = "lt-levels";

      for (let i = 0; i < LEVELS.length; i++) {
        const sw = document.createElement("div");
        sw.className = "lt-swatch";
        const chip = document.createElement("div");
        chip.className = "lt-chip";
        chip.style.background = LEVELS[i];
        sw.appendChild(chip);

        const lbl = document.createElement("div");
        lbl.className = "lbl";
        lbl.innerHTML = `<span class="mono idx">${i}</span><span class="mono hex">${LEVELS[i]}</span>`;
        if (!state.showLabels) lbl.style.display = "none";
        sw.appendChild(lbl);

        grid.appendChild(sw);
      }
      card.appendChild(grid);

      if (state.showGuides) {
        const legend = document.createElement("div");
        legend.className = "lt-legend";
        const mk = (colStart, colEnd, name, hint) => {
          const seg = document.createElement("div");
          seg.className = "seg";
          seg.style.gridColumn = `${colStart} / ${colEnd}`;
          seg.innerHTML = `<div class="tag">${name}<small>${hint}</small></div>`;
          return seg;
        };
        legend.appendChild(mk(1, 5, "暗度", "0–3"));
        legend.appendChild(mk(5, 8, "灰度", "4–6"));
        legend.appendChild(mk(8, 12, "亮度", "7–10"));
        card.appendChild(legend);

        const spans = document.createElement("div");
        spans.className = "lt-spans";
        const spanRow = (label, slotsOn) => {
          const row = document.createElement("div");
          row.className = "lt-spanRow";
          const left = document.createElement("div");
          left.className = "name";
          left.textContent = label;
          const bar = document.createElement("div");
          bar.className = "lt-spanBar";
          for (let i = 0; i < 11; i++) {
            const slot = document.createElement("div");
            slot.className = `slot${slotsOn.includes(i) ? " on" : ""}`;
            bar.appendChild(slot);
          }
          row.appendChild(left);
          row.appendChild(bar);
          return row;
        };

        spans.appendChild(spanRow("短调", [4, 5, 6]));
        spans.appendChild(spanRow("中调", [3, 4, 5, 6, 7]));
        spans.appendChild(spanRow("长调", [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));
        card.appendChild(spans);
      }

      return card;
    }

    function renderMatrixSection() {
      const card = document.createElement("div");
      card.className = "card";

      const head = document.createElement("div");
      head.className = "row";
      head.style.marginBottom = "10px";
      head.innerHTML = `<div class="left"><div class="name">9 种影调（暗/灰/亮 × 短/中/长）</div></div>`;

      const ctrl = document.createElement("div");
      ctrl.className = "lt-templCtrl";

      const restore = document.createElement("button");
      restore.className = "btn small";
      restore.type = "button";
      restore.textContent = "恢复默认";
      restore.style.display = activeTemplate.mode === "custom" ? "" : "none";
      const upload = document.createElement("button");
      upload.className = "btn primary small";
      upload.type = "button";
      upload.textContent = "自己上传（仅SVG）";

      ctrl.appendChild(restore);
      ctrl.appendChild(upload);
      head.appendChild(ctrl);
      card.appendChild(head);

      const meta = document.createElement("div");
      meta.className = "lt-templMeta";
      card.appendChild(meta);

      const warn = document.createElement("div");
      warn.className = "lt-templWarn";
      warn.style.display = "none";
      card.appendChild(warn);

      setTemplateUiEls({ uploadBtn: upload, restoreBtn: restore, status: meta, warn });

      upload.addEventListener("click", onUploadClick);
      restore.addEventListener("click", onRestoreTemplate);

      const matrix = document.createElement("div");

      const cellKey = (posId, lenId) => `${posId}:${lenId}`;
      const ensureCellSeeds = () => {
        if (!state.cellSeeds || typeof state.cellSeeds !== "object") state.cellSeeds = {};
      };
      const ensureLockedBaseSeeds = () => {
        if (!state.lockedBaseSeeds || typeof state.lockedBaseSeeds !== "object") state.lockedBaseSeeds = {};
      };
      const cellSeedFor = (posId, lenId) => {
        const k = cellKey(posId, lenId);
        const extra = typeof state.cellSeeds?.[k] === "number" ? state.cellSeeds[k] : 0;
        const base = typeof state.lockedBaseSeeds?.[k] === "number" ? state.lockedBaseSeeds[k] : state.seed;
        return hashStringToU32(`${base}:${k}:${extra}`);
      };

      cellEls = new Map();
      cellRenderers = new Map();
      cellInfoByKey = new Map();

      const renderCellInto = (cell) => {
        const posId = cell.dataset.positionId;
        const lenId = cell.dataset.lengthId;
        const seed = cellSeedFor(posId, lenId);
        const range = getToneRange({ positionId: posId, lengthId: lenId, seed });

        const rangeEl = cell.querySelector("[data-range]");
        if (rangeEl) rangeEl.textContent = `范围 ${formatRangeLabel(range)}`;

        const cover = cell.querySelector("[data-cover]");
        if (!cover) return;
        const templateSvg = activeTemplate?.svgText || null;
        const templateMode = activeTemplate?.mode === "custom" ? "custom" : "default";
        if (templateSvg) {
          try {
            const k = String(cell.dataset.cellKey || "");
            const rawSpec = state.colorByCell && k && typeof state.colorByCell[k] === "object" ? state.colorByCell[k] : null;
            const colorSpec = sanitizeColorSpec(rawSpec);
            cover.innerHTML = recolorTemplateSvg({
              svgText: templateSvg,
              range,
              uid: `${posId}-${lenId}`,
              positionId: posId,
              lengthId: lenId,
              seed,
              templateMode,
              colorSpec,
              onInfo: (info) => {
                if (!k) return;
                cellInfoByKey.set(k, { ...info, positionId: posId, lengthId: lenId, range });
              },
            });
          } catch (e) {
            console.warn("[levels-tones] render cell failed:", { posId, lenId, range }, e);
            cover.innerHTML = `<div style="padding:10px;color:rgba(234,240,255,.78);font-size:12px;line-height:1.5">该卡片渲染失败：<span class="mono">${String(e?.message || e)}</span></div>`;
          }
        } else {
          cover.innerHTML = `<div style="padding:10px;color:rgba(234,240,255,.75);font-size:12px;line-height:1.5">未能加载模板 SVG：<span class="mono">${TEMPLATE_SVG_URL}</span></div>`;
        }
      };

      const createCell = (pos, len, { withTitle }) => {
        const posId = pos.id;
        const lenId = len.id;
        const k = cellKey(posId, lenId);

        const cell = document.createElement("div");
        cell.className = `lt-cell${k === state.selectedKey ? " is-selected" : ""}`;
        cell.dataset.positionId = posId;
        cell.dataset.lengthId = lenId;
        cell.dataset.cellKey = k;
        cellEls.set(k, cell);
        cellRenderers.set(k, () => renderCellInto(cell));

        cell.addEventListener("click", () => {
          setSelectedKey(k);
        });

        const refresh = document.createElement("button");
        refresh.className = "icon-btn lt-cellRefresh";
        refresh.type = "button";
        refresh.title = "仅刷新此卡片";
        refresh.setAttribute("aria-label", "仅刷新此卡片");
        refresh.textContent = "⟳";
        refresh.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          ensureCellSeeds();
          state.cellSeeds[k] = randomSeed();
          if (state.colorByCell && typeof state.colorByCell === "object" && state.colorByCell[k] && typeof state.colorByCell[k] === "object") {
            delete state.colorByCell[k].tweaks;
          }
          if (k === state.selectedKey) activeTweakIdx = null;
          saveState(state);
          renderCellInto(cell);
          if (k === state.selectedKey) renderColorPanel();
        });

        const lock = document.createElement("button");
        lock.className = "icon-btn lt-cellLock";
        lock.type = "button";
        lock.setAttribute("aria-label", "锁定/解锁此卡片");

        const setLockUi = () => {
          const locked = typeof state.lockedBaseSeeds?.[k] === "number";
          lock.textContent = locked ? "🔒" : "🔓";
          lock.title = locked ? "已锁定（不受全局重新生成影响）" : "锁定（不受全局重新生成影响）";
        };
        setLockUi();

        lock.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          ensureLockedBaseSeeds();
          const locked = typeof state.lockedBaseSeeds?.[k] === "number";
          if (locked) delete state.lockedBaseSeeds[k];
          else state.lockedBaseSeeds[k] = state.seed;
          saveState(state);
          setLockUi();
          renderCellInto(cell);
          if (k === state.selectedKey) renderColorPanel();
        });

        const actions = document.createElement("div");
        actions.className = withTitle ? "lt-cellActions" : "lt-cellActions lt-cellActions--abs";
        actions.appendChild(lock);
        actions.appendChild(refresh);

        if (withTitle) {
          const title = document.createElement("div");
          title.className = "lt-cellTitle";

          const t = document.createElement("div");
          t.className = "t";
          t.appendChild(document.createTextNode(toneTitle(pos.label, len.label)));

          const r = document.createElement("div");
          r.className = "r";
          r.setAttribute("data-range", "");

          title.appendChild(t);
          title.appendChild(r);
          title.appendChild(actions);
          cell.appendChild(title);
        } else {
          cell.appendChild(actions);
        }

        const cover = document.createElement("div");
        cover.setAttribute("data-cover", "");
        cell.appendChild(cover);

        renderCellInto(cell);
        return cell;
      };

      if (state.showGuides) {
        matrix.className = "lt-matrix";

        const corner = document.createElement("div");
        corner.className = "lt-colHead lt-corner";
        corner.textContent = "·";
        matrix.appendChild(corner);

        // Columns: length (短/中/长)
        for (const len of LENGTHS) {
          const col = document.createElement("div");
          col.className = "lt-colHead";
          col.textContent = len.label;
          matrix.appendChild(col);
        }

        // Rows: position (暗/灰/亮)
        for (const pos of POSITIONS) {
          const rowHead = document.createElement("div");
          rowHead.className = "lt-rowHead";
          rowHead.textContent = pos.label;
          matrix.appendChild(rowHead);

          for (const len of LENGTHS) matrix.appendChild(createCell(pos, len, { withTitle: true }));
        }
      } else {
        matrix.className = "lt-matrix lt-matrix--compact";
        for (const pos of POSITIONS) for (const len of LENGTHS) matrix.appendChild(createCell(pos, len, { withTitle: false }));
      }

      card.appendChild(matrix);
      return card;
    }

    function renderAll() {
      root.replaceChildren();

      const wrap = document.createElement("div");
      wrap.className = "grid";

      const intro = document.createElement("div");
      intro.className = "lt";
      intro.innerHTML = `
        <h2>色阶&影调</h2>
        <p class="sub">
          约定：<span class="mono">0–3</span> 为暗度，<span class="mono">4–6</span> 为灰度，<span class="mono">7–10</span> 为亮度；
          短调=连续 3 段，中调=连续 5 段，长调=连续 11 段（0–10 全部）。
        </p>
      `;
      wrap.appendChild(intro);

      wrap.appendChild(renderLevelsSection());
      wrap.appendChild(renderMatrixSection());
      root.appendChild(wrap);
      renderColorPanel();
    }

    const onShowGuides = () => {
      state.showGuides = !!ui.showGuides.checked;
      saveState(state);
      renderAll();
    };
    const onShowLabels = () => {
      state.showLabels = !!ui.showLabels.checked;
      saveState(state);
      renderAll();
    };
    const onTex = () => {
      const v = clamp(Number(ui.tex.value) || 0, 0, 100);
      state.texture = v / 100;
      ui.texVal.textContent = `${Math.round(v)}%`;
      ui.tex.style.setProperty("--p", `${v}%`);
      saveState(state);
      renderAll();
    };

    ui.showGuides.addEventListener("change", onShowGuides);
    ui.showLabels.addEventListener("change", onShowLabels);
    ui.tex.addEventListener("input", onTex);

    // Topic actions: reset / regenerate
    actionsEl.replaceChildren();

    const regenBtn = document.createElement("button");
    regenBtn.className = "icon-btn";
    regenBtn.type = "button";
    regenBtn.title = "重新生成（换一组）";
    regenBtn.setAttribute("aria-label", "重新生成（换一组）");
    regenBtn.textContent = "🎲";
    actionsEl.appendChild(regenBtn);

    const resetBtn = document.createElement("button");
    resetBtn.className = "icon-btn";
    resetBtn.type = "button";
    resetBtn.title = "重置设置";
    resetBtn.setAttribute("aria-label", "重置设置");
    resetBtn.textContent = "⟲";
    actionsEl.appendChild(resetBtn);

    const onRegen = () => {
      state.seed = randomSeed();
      activeTweakIdx = null;
      if (state.colorDraft && typeof state.colorDraft === "object") delete state.colorDraft.tweaks;
      if (state.colorByCell && typeof state.colorByCell === "object") {
        for (const [k, v] of Object.entries(state.colorByCell)) {
          const locked = typeof state.lockedBaseSeeds?.[k] === "number";
          if (locked) continue;
          if (v && typeof v === "object") delete v.tweaks;
        }
      }
      saveState(state);
      renderAll();
    };

    const onReset = () => {
      Kit.storage.remove(STORAGE_KEY);
      Object.assign(state, loadState());
      ensureAllColorSpecs();
      ui.showGuides.checked = !!state.showGuides;
      ui.showLabels.checked = !!state.showLabels;
      ui.tex.value = String(Math.round(state.texture * 100));
      ui.texVal.textContent = `${Math.round(state.texture * 100)}%`;
      restoreDefaultTemplate();
    };
    regenBtn.addEventListener("click", onRegen);
    resetBtn.addEventListener("click", onReset);

    renderAll();

    return () => {
      regenBtn.removeEventListener("click", onRegen);
      resetBtn.removeEventListener("click", onReset);
      actionsEl.replaceChildren();
      ui.showGuides.removeEventListener("change", onShowGuides);
      ui.showLabels.removeEventListener("change", onShowLabels);
      ui.tex.removeEventListener("input", onTex);
      uploadInput?.removeEventListener("change", onUploadChange);
      ui.colorPos?.removeEventListener("change", onSelectChange);
      ui.colorLen?.removeEventListener("change", onSelectChange);
      ui.hue?.removeEventListener("input", onHueInput);
      ui.harmony?.removeEventListener("change", onHarmonyChange);
      ui.sb?.removeEventListener("pointerdown", onSbPointerDown);
      ui.sb?.removeEventListener("pointermove", onSbPointerMove);
      ui.sb?.removeEventListener("pointerup", onSbPointerUp);
      ui.sb?.removeEventListener("pointercancel", onSbPointerUp);
      ui.applyAll?.removeEventListener("click", onApplyAll);
      ui.clearThis?.removeEventListener("click", onClearThis);
      ui.clearAll?.removeEventListener("click", onClearAll);
      tweakUi?.closeBtn?.removeEventListener("click", onTweakClose);
      tweakUi?.resetBtn?.removeEventListener("click", onTweakReset);
      tweakUi?.pad?.removeEventListener("pointerdown", onPadPointerDown);
      tweakUi?.pad?.removeEventListener("pointermove", onPadPointerMove);
      tweakUi?.pad?.removeEventListener("pointerup", onPadPointerUp);
      tweakUi?.pad?.removeEventListener("pointercancel", onPadPointerUp);
      tweakUi?.hueShift?.removeEventListener("input", onHueShiftInput);
      tweakUi?.hueShift?.removeEventListener("change", onHueShiftChange);
      document.removeEventListener("pointerdown", onDocPointerDown, true);
      window.removeEventListener("keydown", onDocKeyDown);
      try {
        tweakUi?.root?.remove?.();
      } catch {}
      if (saveTimer) clearTimeout(saveTimer);
      if (renderTimer) clearTimeout(renderTimer);
      if (renderAllTimer) clearTimeout(renderAllTimer);
      contentEl.replaceChildren();
      panelEl.replaceChildren();
    };
  }

  window.DesignBook?.registerModule?.("color-models/levels-tones", { mount });
})();
